{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 参考 MySQL GeaoZhang：MySQL Airship：MySQL Update time： 2020-09-08 "},"MySQL/MySQL基础/":{"url":"MySQL/MySQL基础/","title":"MySQL基础","keywords":"","body":"MySQL基础 Update time： 2020-08-18 "},"MySQL/MySQL基础/MySQL介绍.html":{"url":"MySQL/MySQL基础/MySQL介绍.html","title":"MySQL介绍","keywords":"","body":"MySQL介绍 SQL是什么？它能做什么？ 对数据库进行查询和修改操作的语言叫做 SQL（Structured Query Language，结构化查询语言）。SQL 语言是目前广泛使用的关系数据库标准语言，是各种数据库交互方式的基础。 著名的大型商用数据库 Oracle、DB2、Sybase、SQL Server，开源的数据库 PostgreSQL、MySQL，甚至一些小型的数据库 Access 等都支持 SQL。近些年蓬勃发展的 NoSQL 系统最初是宣称不再需要 SQL 的，后来也不得不修正为 Not Only SQL，来拥抱 SQL。 SQL 是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。与其他程序设计语言（如 C语言、Java 等）不同的是，SQL 由很少的关键字组成，每个 SQL 语句通过一个或多个关键字构成。 SQL 具有如下优点。 一体化：SQL 集数据定义、数据操作和数据控制于一体，可以完成数据库中的全部工作。 使用方式灵活：SQL 具有两种使用方式，可以直接以命令方式交互使用；也可以嵌入使用，嵌入C、C++、Fortran、COBOL、Java 等语言中使用。 非过程化：只提操作要求，不必描述操作步骤，也不需要导航。使用时只需要告诉计算机“做什么”，而不需要告诉它“怎么做”，存储路径的选择和操作的执行由数据库管理系统自动完成。 语言简洁、语法简单：该语言的语句都是由描述性很强的英语单词组成，而且这些单词的数目不多。 SQL 包含以下 4 部分： 1）数据定义语言（Data Definition Language，DDL） 用来创建或删除数据库以及表等对象，主要包含以下几种命令： DROP：删除数据库和表等对象 CREATE：创建数据库和表等对象 ALTER：修改数据库和表等对象的结构 2）数据操作语言（Data Manipulation Language，DML） 用来变更表中的记录，主要包含以下几种命令： SELECT：查询表中的数据 INSERT：向表中插入新数据 UPDATE：更新表中的数据 DELETE：删除表中的数据 3）数据查询语言（Data Query Language，DQL） 用来查询表中的记录，主要包含 SELECT 命令，来查询表中的数据。 4）数据控制语言（Data Control Language，DCL） 用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对数据库中的用户设定权限。主要包含以下几种命令： GRANT：赋予用户操作权限 REVOKE：取消用户的操作权限 COMMIT：确认对数据库中的数据进行的变更 ROLLBACK：取消对数据库中的数据进行的变更 Update time： 2020-08-18 "},"MySQL/MySQL基础/MySQL书写规范及注释.html":{"url":"MySQL/MySQL基础/MySQL书写规范及注释.html","title":"MySQL书写规范及注释","keywords":"","body":"MySQL书写规范及注释 SQL 语句要以分号;结尾 在 RDBMS （关系型数据库）当中，SQL 语句是逐条执行的，一条 SQL 语句代表着数据库的一个操作。 我们通常在句子的句尾加注标点表示这句话结束，中文句子以句号。结尾，英文以点号.结尾，而 SQL 语句则使用英文分号;结尾。 SQL 语句不区分大小写 SQL 不区分关键字的大小写。例如，不管写成 SELECT 还是 select，解释都是一样的。表名和列名也是如此。 提示：关键字是数据库事先定义的，有特别意义的单词。 虽然可以根据个人喜好选择大写还是小写（或大小写混杂），但为了理解起来更加容易，本教程使用以下规则来书写 SQL 语句。 关键字大写 数据库名、表名和列名等小写 需要注意的是，插入到表中的数据是区分大小写的。例如，向数据库中插入单词 Computer、COMPUTER 或 computer，这三个是不一样的数据 常数的书写方式是固定的 SQL 语句常常需要直接书写字符串、日期或者数字。例如，书写向表中插入字符串、日期或者数字等数据的 SQL 语句。 在 SQL 语句中直接书写的字符串、日期或者数字等称为常数。常数的书写方式如下所示： SQL 语句中含有字符串的时候，需要像 'abc' 这样，使用英文单引号'将字符串括起来，用来标识这是一个字符串。 SQL 语句中含有日期的时候，同样需要使用英文单引号将其括起来。日期的格式有很多种（'26 Jan 2010' 或者'10/01/26' 等），本教程统一使用 '2020-01-26' 这种'年-月-日'的格式。 在 SQL 语句中书写数字的时候，不需要使用任何符号标识，直接写成 1000 这样的数字即可。 注意：列名不是字符串，不能使用单引号。在MySQL 中可以用倒引号```把表名和列名括起来。 单词需要用半角空格或者换行来分隔 SQL 语句的单词之间必须使用半角空格（英文空格）或换行符来进行分隔。没有分隔的语句会发生错误，无法正常执行。 下面是分隔和未分隔的 SQL 语句： CREATE TABLE Product（正确） CREATETABLE Product（错误） CREATE TABLEProduct（错误） 不能使用全角空格（中文空格）作为单词的分隔符，否则会发生错误，出现无法预期的结果。 SQL 语句中的标点符号必须都是英文状态下的，即半角字。 注释：单行注释和多行注释 每一种语言都有自己的注释方式，代码量越多，代码注释的重要性也就越明显。一般情况下，注释可以出现在程序中的任何位置，用来向用户或程序员提示或解释程序的功能及作用。 下面主要介绍 MySQL 中 SQL 语句的注释方法。 注释在 SQL 语句中用来标识说明或者注意事项的部分，对 SQL 的执行没有任何影响。因此，注释内容中无论是英文字母还是汉字都可以随意使用。 MySQL 注释分为单行注释和多行注释，下面分别来介绍这两种注释。 MySQL 单行注释 1) 单行注释可以使用#注释符，#注释符后直接加注释内容。格式如下： #注释内容 单行注释使用注释符#的示例如下： #从结果中删除重复行 SELECT DISTINCT product_id, purchase_price FROM Product; 2) 单行注释可以使用--注释符，--注释符后需要加一个空格，注释才能生效。格式如下： -- 注释内容 单行注释使用注释符--的示例如下： -- 从结果中删除重复行 SELECT DISTINCT product_id, purchase_price FROM Product; #和--的区别就是：#后面直接加注释内容，而--的第 2 个破折号后需要跟一个空格符在加注释内容。 MySQL 多行注释 多行注释使用/* */注释符。/*用于注释内容的开头，*/用于注释内容的结尾。多行注释格式如下： /* 第一行注释内容 第二行注释内容 */ 注释内容写在/*和*/之间，可以跨多行。 多行注释的使用示例如下 /*这条SELECT语句， 会从结果中删除重复行*/ SELECT DISTINCT product_id, purchase_price FROM Product; 任何注释（单行注释和多行注释）都可以插在 SQL 语句中，且注释可以放在 SQL 语句中的任意位置。 在 SQL 语句中插入单行注释，如下所示： SELECT DISTINCT product_id, purchase_price-- 从结果中删除重复行。 FROM Product;SELECT DISTINCT product_id, purchase_price#从结果中删除重复行。 FROM Product; 在 SQL 语句中插入多行注释，如下所示： SELECT DISTINCT product_id, purchase_price/* 这条SELECT语句， 会从结果中删除重复行。*/ FROM Product; 注释可以写在任何 SQL 语句当中，且 SQL 语句中对注释的数量没有限制。 MySQL 注释能够帮助阅读者更好地理解 SQL 语句，特别是在使用复杂的 SQL 语句时，所以大家应该尽量多添加一些简明易懂的注释。 Update time： 2020-08-18 "},"MySQL/MySQL基础/创建、查看、切换及删除数据库.html":{"url":"MySQL/MySQL基础/创建、查看、切换及删除数据库.html","title":"创建、查看、切换及删除数据库","keywords":"","body":"创建、查看及切换数据库 创建数据库（CREATE DATABASE语句） 在 MySQL 中，可以使用 CREATE DATABASE 语句创建数据库，语法格式如下： CREATE DATABASE [IF NOT EXISTS] [[DEFAULT] CHARACTER SET ] [[DEFAULT] COLLATE ]; [ ]中的内容是可选的。语法说明如下： ：创建数据库的名称。MySQL 的数据存储区将以目录方式表示 MySQL 数据库，因此数据库名称必须符合操作系统的文件夹命名规则，不能以数字开头，尽量要有实际意义。注意在 MySQL 中不区分大小写。 IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。 [DEFAULT] CHARACTER SET：指定数据库的字符集。指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况。如果在创建数据库时不指定字符集，那么就使用系统的默认字符集。 [DEFAULT] COLLATE：指定字符集的默认校对规则。 MySQL 的字符集（CHARACTER）和校对规则（COLLATION）是两个不同的概念。字符集是用来定义 MySQL 存储字符串的方式，校对规则定义了比较字符串的方式。后面我们会单独讲解 MySQL 的字符集和校对规则。 实例1：最简单的创建 MySQL 数据库的语句 在 MySQL 中创建一个名为 test_db 的数据库。在 MySQL 命令行客户端输入 SQL 语句CREATE DATABASE test_db;即可创建一个数据库，输入的 SQL 语句与执行结果如下。 mysql> CREATE DATABASE test_db; Query OK, 1 row affected (0.12 sec); “Query OK, 1 row affected (0.12 sec);”提示中，“Query OK”表示上面的命令执行成功，“1 row affected”表示操作只影响了数据库中一行的记录，“0.12 sec”则记录了操作执行的时间。 若再次输入CREATE DATABASE test_db;语句，则系统会给出错误提示信息，如下所示： mysql> CREATE DATABASE test_db; ERROR 1007 (HY000): Can't create database 'test_db'; database exists 提示不能创建“test_db”数据库，数据库已存在。MySQL 不允许在同一系统下创建两个相同名称的数据库。 可以加上IF NOT EXISTS从句，就可以避免类似错误，如下所示： mysql> CREATE DATABASE IF NOT EXISTS test_db; Query OK, 1 row affected (0.12 sec) 实例2：创建 MySQL 数据库时指定字符集和校对规则 使用 MySQL 命令行工具创建一个测试数据库，命名为 test_db_char，指定其默认字符集为 utf8，默认校对规则为 utf8_chinese_ci（简体中文，不区分大小写），输入的 SQL 语句与执行结果如下所示： mysql> CREATE DATABASE IF NOT EXISTS test_db_char -> DEFAULT CHARACTER SET utf8 -> DEFAULT COLLATE utf8_chinese_ci; Query OK, 1 row affected (0.03 sec) 这时，可以使用SHOW CREATE DATABASE查看 test_db_char 数据库的定义声明，发现该数据库的指定字符集为 utf8，运行结果如下所示： mysql> SHOW CREATE DATABASE test_db_char; +--------------+-----------------------------------------------------+ | Database | Create Database | +--------------+-----------------------------------------------------+ | test_db_char | CREATE DATABASE `test_db_char` /*!40100 DEFAULT CHARACTER SET utf8 */ | +--------------+-----------------------------------------------------+ 1 row in set (0.00 sec) “1 row in set (0.00 sec)”表示集合中有 1 行信息，处理时间为 0.00秒。时间为 0.00 秒并不代表没有花费时间，而是时间非常短，小于 0.01 秒。 显示数据库 SHOW DATABASES语句列出了MySQL数据库服务器中的所有数据库。您可以使用SHOW DATABASES语句检查您创建的数据库，或者在创建新数据库之前查看数据库服务器上的所有数据库，例如： SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | mysqldemo | +--------------------+ 4 rows in set (0.01 sec) 如输出中清楚所示，我们在MySQL数据库服务器中有三个数据库。information_schema 和mysql我们安装MySQL时可用的默认数据库，mysqldemo是我们创建的新数据库。 切换数据库 在使用特定数据库之前，必须使用USE 语句告诉MySQL您要使用哪个数据库。 USE database_name; 您可以使用以下USE语句选择mysqldemo 示例数据库： USE mysqldemo; 删除数据库 删除数据库意味着永久删除数据库中包含的所有表和数据库本身。因此，执行此查询时要格外小心非常重要。 要删除数据库，请使用以下DROP DATABASE 语句： DROP DATABASE [IF EXISTS] database_name; DROP DATABASE 子句后面是您要删除的数据库名称。与CREATE DATABASE 语句类似，IF EXISTS 语句的可选部分，用于防止您删除数据库服务器中不存在的数据库。 如果要练习DROP DATABASE 语句，可以创建一个新数据库，确保它已创建并删除它。 我们来看看以下查询： CREATE DATABASE IF NOT EXISTS tempdb; SHOW DATABASES; DROP DATABASE IF EXISTS tempdb; 三个陈述的顺序如下： 我们使用CREATE DATABASE语句创建了一个tempdb数据库。 我们使用SHOW DATABASES语句显示所有数据库。 我们使用DROP DATABASE语句删除tempdb。 Update time： 2020-08-18 "},"MySQL/MySQL基础/修改数据库：ALTER DATABASE.html":{"url":"MySQL/MySQL基础/修改数据库：ALTER DATABASE.html","title":"修改数据库：ALTER DATABASE","keywords":"","body":"修改数据库：ALTER DATABASE 在 MySQL 数据库中只能对数据库使用的字符集和校对规则进行修改，数据库的这些特性都储存在 db.opt 文件中。下面我们来介绍一下修改数据库的基本操作。 在 MySQL 中，可以使用 ALTER DATABASE 来修改已经被创建或者存在的数据库的相关参数。修改数据库的语法格式为： ALTER DATABASE [数据库名] { [ DEFAULT ] CHARACTER SET | [ DEFAULT ] COLLATE } 语法说明如下： ALTER DATABASE 用于更改数据库的全局特性。 使用 ALTER DATABASE 需要获得数据库 ALTER 权限。 数据库名称可以忽略，此时语句对应于默认数据库。 CHARACTER SET 子句用于更改默认的数据库字符集。 例 1 查看 test_db 数据库的定义声明的执行结果如下所示： mysql> SHOW CREATE DATABASE test_db; +----------+--------------------------------------------------------+ | Database | Create Database | +----------+--------------------------------------------------------+ | test_db | CREATE DATABASE `test_db` /*!40100 DEFAULT CHARACTER SET utf8 */| +----------+--------------------------------------------------------+ 1 row in set (0.05 sec) 使用命令行工具将数据库 test_db 的指定字符集修改为 gb2312，默认校对规则修改为 utf8_unicode_ci，输入 SQL 语句与执行结果如下所示： mysql> CREATE DATABASE test_db -> DEFAULT CHARACTER SET gb2312 -> DEFAULT COLLATE gb2312_chinese_ci; mysql> SHOW CREATE DATABASE test_db; +----------+--------------------------------------------------------+ | Database | Create Database | +----------+--------------------------------------------------------+ | test_db | CREATE DATABASE `test_db` /*!40100 DEFAULT CHARACTER SET gb2312 */| +----------+--------------------------------------------------------+ 1 row in set (0.00 sec) alter 修改表 添加索引 Update time： 2020-09-11 "},"MySQL/MySQL基础/数据表管理.html":{"url":"MySQL/MySQL基础/数据表管理.html","title":"数据表管理","keywords":"","body":"数据表管理 数据表是数据库的重要组成部分，每一个数据库都是由若干个数据表组成的。换句话说，没有数据表就无法在数据库中存放数据。 比如，在电脑中创建一个空文件夹，如果要把“Hello C语言中文网”存放到文件夹中，必须把它写在 Word 文档、记事本或其它能存放文本的文档中。这里的空文件夹就相当于数据库，存放文本的文档就相当于数据表。 创建数据表（CREATE TABLE语句） 在创建数据库之后，接下来就要在数据库中创建数据表。所谓创建数据表，指的是在已经创建的数据库中建立新表。 创建数据表的过程是规定数据列的属性的过程，同时也是实施数据完整性（包括实体完整性、引用完整性和域完整性）约束的过程。接下来我们介绍一下创建数据表的语法形式。 基本语法 在 MySQL 中，可以使用 CREATE TABLE 语句创建表。其语法格式为： CREATE TABLE ([表定义选项])[表选项][分区选项]; 其中，[表定义选项]的格式为： [,…] CREATE TABLE 命令语法比较多，其主要是由表创建定义（create-definition）、表选项（table-options）和分区选项（partition-options）所组成的。 这里首先描述一个简单的新建表的例子，然后重点介绍 CREATE TABLE 命令中的一些主要的语法知识点。 CREATE TABLE 语句的主要语法及使用说明如下： CREATE TABLE：用于创建给定名称的表，必须拥有表CREATE的权限。 ：指定要创建表的名称，在 CREATE TABLE 之后给出，必须符合标识符命名规则。表名称被指定为 db_name.tbl_name，以便在特定的数据库中创建表。无论是否有当前数据库，都可以通过这种方式创建。在当前数据库中创建表时，可以省略 db-name。如果使用加引号的识别名，则应对数据库和表名称分别加引号。例如，'mydb'.'mytbl' 是合法的，但 'mydb.mytbl' 不合法。 ：表创建定义，由列名（col_name）、列的定义（column_definition）以及可能的空值说明、完整性约束或表索引组成。 默认的情况是，表被创建到当前的数据库中。若表已存在、没有当前数据库或者数据库不存在，则会出现错误。 提示：使用 CREATE TABLE 创建表时，必须指定以下信息： 要创建的表的名称不区分大小写，不能使用SQL语言中的关键字，如DROP、ALTER、INSERT等。 数据表中每个列（字段）的名称和数据类型，如果创建多个列，要用逗号隔开。 在指定的数据库中创建表 数据表属于数据库，在创建数据表之前，应使用语句“USE”指定操作在哪个数据库中进行，如果没有选择数据库，就会抛出 No database selected 的错误。 【实例 1】创建员工表 tb_emp1，结构如下表所示。 字段名称 数据类型 备注 id INT(ll) 员工编号 name VARCHAR(25) 员工名称 deptld INT(ll) 所在部门编号 salary FLOAT 工资 选择创建表的数据库 test_db，创建 tb_emp1 数据表，输入的 SQL 语句和运行结果如下所示。 mysql> USE test_db; Database changed mysql> CREATE TABLE tb_emp1 -> ( -> id INT(11), -> name VARCHAR(25), -> deptId INT(11), -> salary FLOAT -> ); Query OK, 0 rows affected (0.37 sec) 语句执行后，便创建了一个名称为 tb_emp1 的数据表，使用 SHOW TABLES；语句查看数据表是否创建成功，如下所示。 mysql> SHOW TABLES; +--------------------+ | Tables_in_test_db | +--------------------+ | tb_emp1 | +--------------------+ 1 rows in set (0.00 sec) 查看表结构 在 MySQL 中，使用 SQL 语句创建好数据表之后，可以查看结构的定义，以确认表的定义是否正确。在 MySQL 中，查看表结构可以使用 DESCRIBE 和 SHOW CREATE TABLE 语句。 DESCRIBE/DESC 语句可以查看表的字段信息，包括字段名、字段数据类型、是否为主键、是否有默认值等，语法规则如下： DESCRIBE ; -- 或简写成： DESC ; 【实例 2】使用 DESCRIBE 查看表 tb_emp1 的结构，输入的 SQL 语句和运行结果如下所示。 mysql> DESCRIBE tb_emp1; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(25) | YES | | NULL | | | deptId | int(11) | YES | | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 4 rows in set (0.14 sec) 其中，各个字段的含义如下： Null：表示该列是否可以存储 NULL 值。 Key：表示该列是否已编制索引。PRI 表示该列是表主键的一部分，UNI 表示该列是 UNIQUE 索引的一部分，MUL 表示在列中某个给定值允许出现多次。 Default：表示该列是否有默认值，如果有，值是多少。 Extra：表示可以获取的与给定列有关的附加信息，如 AUTO_INCREMENT 等。 SHOW CREATE TABLE 语句可以用来显示创建表时的CREATE TABLE语句，语法格式如下： SHOW CREATE TABLE \\G； 【实例 3】使用 SHOW CREATE TABLE 查看表 tb_emp1 的详细信息，输入的 SQL 语句和运行结果如下所示。 mysql> SHOW CREATE TABLE tb_emp1\\G *************************** 1. row *************************** Table: tb_emp1 Create Table: CREATE TABLE `tb_emp1` ( `id` int(11) DEFAULT NULL, `name` varchar(25) DEFAULT NULL, `deptId` int(11) DEFAULT NULL, `salary` float DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=gb2312 1 row in set (0.03 sec) 提示：使用 SHOW CREATE TABLE 语句不仅可以查看创建表时的详细语句，而且可以查看存储引擎和字符编码。如果不加“\\G”参数，显示的结果可能非常混乱，加上“\\G”参数之后，可使显示的结果更加直观，易于查看。 修改数据表: ALTER TABLE 修改数据表的前提是数据库中已经存在该表。修改表指的是修改数据库中已经存在的数据表的结构。修改数据表的操作也是数据库管理中必不可少的，就像画素描一样，画多了可以用橡皮擦掉，画少了可以用笔加上。 不了解如何修改数据表，就相当于是我们只要画错了就要扔掉重画，这样就增加了不必要的成本。 在 MySQL 中可以使用 ALTER TABLE 语句来改变原有表的结构，例如增加或删减列、更改原有列类型、重新命名列或表等。 其语法格式如下： ALTER TABLE [修改选项] 修改选项的语法格式如下： { ADD COLUMN | CHANGE COLUMN | ALTER COLUMN { SET DEFAULT | DROP DEFAULT } | MODIFY COLUMN | DROP COLUMN | RENAME TO | CHARACTER SET | COLLATE } 修改表名 MySQL 通过 ALTER TABLE 语句来实现表名的修改，语法规则如下： ALTER TABLE RENAME [TO] ； 其中，TO 为可选参数，使用与否均不影响结果。 例 1 使用 ALTER TABLE 将数据表 student 改名为 tb_students_info，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE student RENAME TO tb_students_info; Query OK, 0 rows affected (0.01 sec) mysql> SHOW TABLES; +------------------+ | Tables_in_test | +------------------+ | tb_students_info | +------------------+ 1 row in set (0.00 sec) 提示：修改表名并不修改表的结构，因此修改名称后的表和修改名称前的表的结构是相同的。用户可以使用 DESC 命令查看修改后的表结构， 修改表字符集 MySQL 通过 ALTER TABLE 语句来实现表字符集的修改，语法规则如下： ALTER TABLE 表名 [DEFAULT] CHARACTER SET [DEFAULT] COLLATE ; 其中，DEFAULT 为可选参数，使用与否均不影响结果。 例 2 使用 ALTER TABLE 将数据表 tb_students_info 的字符集修改为 gb2312，校对规则修改为 gb2312_chinese_ci。SQL 语句和运行结果如下所示。 mysql> ALTER TABLE tb_students_info CHARACTER SET gb2312 DEFAULT COLLATE gb2312_chinese_ci; Query OK, 0 rows affected (0.08 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> SHOW CREATE TABLE tb_students_info \\G *************************** 1. row *************************** Table: tb_students_info Create Table: CREATE TABLE `tb_students_info` ( `id` int(11) NOT NULL, `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=MyISAM DEFAULT CHARSET=gb2312 1 row in set (0.00 sec) 数据表添加字段（三种方式） MySQL 数据表是由行和列构成的，通常把表的“列”称为字段（Field），把表的“行”称为记录（Record）。随着业务的变化，可能需要在已有的表中添加新的字段。 MySQL 允许在开头、中间和结尾处添加字段。 在末尾添加字段 一个完整的字段包括字段名、数据类型和约束条件。MySQL 添加字段的语法格式如下： ALTER TABLE ADD [约束条件]; 对语法格式的说明如下： 为数据表的名字； 为所要添加的字段的名字； 为所要添加的字段能存储数据的数据类型； [约束条件] 是可选的，用来对添加的字段进行约束。 这种语法格式默认在表的最后位置（最后一列的后面）添加新字段。 注意：本节我们只添加新的字段，不关注它的约束条件。 实例1 在 test 数据库中新建 student 数据表，SQL 语句和运行结果如下： mysql> USE test; Database changed mysql> CREATE TABLE student ( -> id INT(4), -> name VARCHAR(20), -> sex CHAR(1)); Query OK, 0 rows affected (0.09 sec) 使用 DESC 查看 student 表结构，SQL 语句和运行结果如下： mysql> DESC student; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | id | int(4) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | sex | char(1) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 3 rows in set (0.01 sec) 使用 ALTER TABLE 语句添加一个 INT 类型的字段 age，SQL 语句和运行结果如下： mysql> ALTER TABLE student ADD age INT(4); Query OK, 0 rows affected (0.16 sec) Records: 0 Duplicates: 0 Warnings: 0 使用 DESC 查看 student 表结构，检验 age 字段是否添加成功。SQL 语句和运行结果如下： mysql> DESC student; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | id | int(4) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | sex | char(1) | YES | | NULL | | | age | int(4) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 4 rows in set (0.00 sec) 由运行结果可以看到，student 表已经添加了 age 字段，且该字段在表的最后一个位置，添加字段成功。 在开头添加字段 MySQL 默认在表的最后位置添加新字段，如果希望在开头位置（第一列的前面）添加新字段，那么可以使用 FIRST 关键字，语法格式如下： ALTER TABLE ADD [约束条件] FIRST; FIRST 关键字一般放在语句的末尾。 实例2 使用 ALTER TABLE 语句在表的第一列添加 INT 类型的字段 stuId，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE student ADD stuId INT(4) FIRST; Query OK, 0 rows affected (0.14 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC student; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | stuId | int(4) | YES | | NULL | | | id | int(4) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | sex | char(1) | YES | | NULL | | | age | int(4) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 5 rows in set (0.00 sec) 由运行结果可以看到，student 表中已经添加了 stuId 字段，且该字段在表中的第一个位置，添加字段成功。 在中间位置添加字段 MySQL 除了允许在表的开头位置和末尾位置添加字段外，还允许在中间位置（指定的字段之后）添加字段，此时需要使用AFTER关键字，语法格式如下： ALTER TABLE ADD [约束条件] AFTER ; AFTER的作用是将新字段添加到某个已有字段后面。 注意，只能在某个已有字段的后面添加新字段，不能在它的前面添加新字段。 实例3 使用 ALTER TABLE 语句在 student 表中添加名为 stuno，数据类型为 INT 的字段，stuno 字段位于 name 字段的后面。SQL 语句和运行结果如下： mysql> ALTER TABLE student ADD stuno INT(11) AFTER name; Query OK, 0 rows affected (0.13 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC student; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | stuId | int(4) | YES | | NULL | | | id | int(4) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | stuno | int(11) | YES | | NULL | | | sex | char(1) | YES | | NULL | | | age | int(4) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 6 rows in set (0.00 sec) 由运行结果可以看到，student 表中已经添加了 stuId 字段，且该字段在 name 字段后面的位置，添加字段成功。 修改/删除字段 修改字段名称 MySQL 中修改表字段名的语法规则如下： ALTER TABLE CHANGE ； 其中： 旧字段名：指修改前的字段名； 新字段名：指修改后的字段名； 新数据类型：指修改后的数据类型，如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样，但数据类型不能为空。 例 1 使用 ALTER TABLE 修改表 tb_emp1 的结构，将 col1 字段名称改为 col3，同时将数据类型变为 CHAR(30)，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE tb_emp1 -> CHANGE col1 col3 CHAR(30); Query OK, 0 rows affected (0.76 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC tb_emp1; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | col3 | char(30) | YES | | NULL | | | id | int(11) | YES | | NULL | | | name | varchar(30) | YES | | NULL | | | deptId | int(11) | YES | | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 5 rows in set (0.01 sec) CHANGE 也可以只修改数据类型，实现和 MODIFY 同样的效果，方法是将 SQL 语句中的“新字段名”和“旧字段名”设置为相同的名称，只改变“数据类型”。 提示：由于不同类型的数据在机器中的存储方式及长度并不相同，修改数据类型可能会影响数据表中已有的数据记录，因此，当数据表中已经有数据时，不要轻易修改数据类型。 修改字段数据类型 修改字段的数据类型就是把字段的数据类型转换成另一种数据类型。在 MySQL 中修改字段数据类型的语法规则如下： ALTER TABLE MODIFY 其中： 表名：指要修改数据类型的字段所在表的名称； 字段名：指需要修改的字段； 数据类型：指修改后字段的新数据类型。 例 2 使用 ALTER TABLE 修改表 tb_emp1 的结构，将 name 字段的数据类型由 VARCHAR(22) 修改成 VARCHAR(30)，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE tb_emp1 -> MODIFY name VARCHAR(30); Query OK, 0 rows affected (0.15 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC tb_emp1; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | col1 | int(11) | YES | | NULL | | | id | int(11) | YES | | NULL | | | name | varchar(30) | YES | | NULL | | | col2 | int(11) | YES | | NULL | | | deptId | int(11) | YES | | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 6 rows in set (0.00 sec) 语句执行后，发现表 tb_emp1 中 name 字段的数据类型已经修改成 VARCHAR(30)，修改成功。 删除字段 删除字段是将数据表中的某个字段从表中移除，语法格式如下： ALTER TABLE DROP ； 其中，“字段名”指需要从表中删除的字段的名称。 例 3 使用 ALTER TABLE 修改表 tb_emp1 的结构，删除 col2 字段，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE tb_emp1 -> DROP col2; Query OK, 0 rows affected (0.53 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC tb_emp1; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | col1 | int(11) | YES | | NULL | | | id | int(11) | YES | | NULL | | | name | varchar(30) | YES | | NULL | | | deptId | int(11) | YES | | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 5 rows in set (0.00 sec) 删除数据表（DORP TABLE语句） 在 MySQL 数据库中，对于不再需要的数据表，我们可以将其从数据库中删除。 在删除表的同时，表的结构和表中所有的数据都会被删除，因此在删除数据表之前最好先备份，以免造成无法挽回的损失。 基本语法 使用 DROP TABLE 语句可以删除一个或多个数据表，语法格式如下： DROP TABLE [IF EXISTS] 表名1 [ ,表名2, 表名3 ...] 对语法格式的说明如下： 表名1, 表名2, 表名3 ...表示要被删除的数据表的名称。DROP TABLE 可以同时删除多个表，只要将表名依次写在后面，相互之间用逗号隔开即可。 IF EXISTS 用于在删除数据表之前判断该表是否存在。如果不加 IF EXISTS，当数据表不存在时 MySQL 将提示错误，中断 SQL 语句的执行；加上 IF EXISTS 后，当数据表不存在时 SQL 语句可以顺利执行，但是会发出警告（warning）。 两点注意： 用户必须拥有执行 DROP TABLE 命令的权限，否则数据表不会被删除。 表被删除时，用户在该表上的权限不会自动删除。 删除表的实例 选择数据库 test_db，创建 tb_emp3 数据表，输入的 SQL 语句和运行结果如下所示。 mysql> USE test_db; Database changed mysql> CREATE TABLE tb_emp3 -> ( -> id INT(11), -> name VARCHAR(25), -> deptId INT(11), -> salary FLOAT -> ); Query OK, 0 rows affected (0.27 sec) mysql> SHOW TABLES; +--------------------+ | Tables_in_test_db | +--------------------+ | tb_emp2 | | tb_emp3 | +--------------------+ 2 rows in set (0.00 sec) 由运行结果可以看出，test_tb 数据库中有 tb_emp2 和 tb_emp3 两张数据表。 我们来删除数据表 tb_emp3，输入的 SQL 语句和运行结果如下所示： mysql> DROP TABLE tb_emp3; Query OK, 0 rows affected (0.22 sec) mysql> SHOW TABLES; +--------------------+ | Tables_in_test_db | +--------------------+ | tb_emp2 | +--------------------+ 1 rows in set (0.00 sec) 执行结果可以看到，test_db 数据库的数据表列表中已经不存在名称为 tb_emp3 的表，删除操作成功。 删除被其它表关联的主表 数据表之间经常存在外键关联的情况，这时如果直接删除父表，会破坏数据表的完整性，也会删除失败。 删除父表有以下两种方法： 先删除与它关联的子表，再删除父表；但是这样会同时删除两个表中的数据。 将关联表的外键约束取消，再删除父表；适用于需要保留子表的数据，只删除父表的情况。 下面介绍了如何取消关联表的外键约束并删除主表，也就是上面所说的删除父表的第二种方法。 在数据库中创建两个关联表。创建表 tb_emp4 的 SQL 语句如下： CREATE TABLE tb_emp4 ( id INT(11) PRIMARY KEY, name VARCHAR(22), location VARCHAR (50) ); 接下来创建表 tb_emp5，SQL 语句如下： CREATE TABLE tb_emp5 ( id INT(11) PRIMARY KEY, name VARCHAR(25), deptId INT(11), salary FLOAT, CONSTRAINT fk_emp4_emp5 FOREIGN KEY (deptId) REFERENCES tb_emp4(id) ); 使用 SHOW CREATE TABLE 命令查看表 tb_ emp5 的外键约束，SQL 语句和运行结果如下： mysql> SHOW CREATE TABLE tb_emp5\\G; *************************** 1. row *************************** Table: tb_emp5 Create Table: CREATE TABLE `tb_emp5` ( `id` int(11) NOT NULL, `name` varchar(25) DEFAULT NULL, `deptId` int(11) DEFAULT NULL, `salary` float DEFAULT NULL, PRIMARY KEY (`id`), KEY `fk_emp4_emp5` (`deptId`), CONSTRAINT `fk_emp4_emp5` FOREIGN KEY (`deptId`) REFERENCES `tb_emp4` (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=latin1 1 row in set (0.00 sec) 由运行结果可以看出，tbemp5 表为子表，具有名称为 fk_emp4_emp5 的外键约束；tb_emp4 为父表，其主键 id 被子表 tb emp5 所关联。 删除被数据表 tb_emp5 关联的数据表 tb_emp4，SQL 语句如下： mysql> DROP TABLE tb_emp4; ERROR 1217 (23000): Cannot delete or update a parent row: a foreign key constraint fails 由运行结果可以看出，当主表在存在外键约束时，不能被直接删除。 下面解除子表 tb_emp5 的外键约束，SQL语句和运行结果如下： mysql> ALTER TABLE tb_emp5 DROP FOREIGN KEY fk_emp4_emp5; Query OK, 0 rows affected (0.03 sec) Records: 0 Duplicates: 0 Warnings: 0 语句成功执行后，会取消表 tb_emp4 和表 tb_emp5 之间的关联关系。 解除关联关系后，可以使用 DROP TABLE 语句直接删除父表 tb_emp4，SQL 语句如下： DROP TABLE tb_emp4; 最后通过 SHOW TABLES 命令查看数据表列表，如下所示： mysql> show tables; +----------------+ | Tables_in_test | +----------------+ | tb_emp5 | | temp | +----------------+ 2 rows in set (0.00 sec) 可以发现，数据库列表中已经不存在名称为 tb_emp4 的表，删除成功。 查看表结构命令 创建完数据表之后，经常需要查看表结构（表信息）。在 MySQL 中，可以使用 DESCRIBE 和 SHOW CREATE TABLE 命令来查看数据表的结构。 DESCRIBE：以表格的形式展示表结构 DESCRIBE/DESC 语句会以表格的形式来展示表的字段信息，包括字段名、字段数据类型、是否为主键、是否有默认值等，语法格式如下： DESCRIBE ; -- 或简写成： DESC ; 【实例1】分别使用 DESCRIBE 和 DESC 查看表 tb_emp1 的表结构，SQL 语句和运行结果如下： mysql> DESCRIBE tb_emp1; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(25) | YES | | NULL | | | deptId | int(11) | YES | | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 4 rows in set (0.14 sec) mysql> DESC tb_emp1; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | id | int(11) | YES | | NULL | | | name | varchar(25) | YES | | NULL | | | deptId | int(11) | YES | | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 4 rows in set (0.14 sec) 其中，各个字段的含义如下： Null：表示该列是否可以存储 NULL 值。 Key：表示该列是否已编制索引。PRI 表示该列是表主键的一部分，UNI 表示该列是 UNIQUE 索引的一部分，MUL 表示在列中某个给定值允许出现多次。 Default：表示该列是否有默认值，如果有，值是多少。 Extra：表示可以获取的与给定列有关的附加信息，如 AUTO_INCREMENT 等。 SHOW CREATE TABLE：以SQL语句的形式展示表结构 SHOW CREATE TABLE 命令会以 SQL 语句的形式来展示表信息。和 DESCRIBE 相比，SHOW CREATE TABLE 展示的内容更加丰富，它可以查看表的存储引擎和字符编码；另外，你还可以通过\\g或者\\G参数来控制展示格式。 SHOW CREATE TABLE 的语法格式如下： SHOW CREATE TABLE ; 在 SHOW CREATE TABLE 语句的结尾处（分号前面）添加\\g或者\\G参数可以改变展示形式。 【实例2】使用 SHOW CREATE TABLE 语句查看表 tb_emp1 的详细信息，一次使用\\g结尾，一次不使用： mysql> SHOW CREATE TABLE tb_emp1; +---------+------------------------------------------------+ | Table | Create Table | +---------+------------------------------------------------+ | tb_emp1 | CREATE TABLE `tb_emp1` ( `id` int(11) DEFAULT NULL, `name` varchar(25) DEFAULT NULL, `salary` float DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=gb2312 | +---------+------------------------------------------------+ 1 row in set (0.01 sec) mysql> SHOW CREATE TABLE tb_emp1 \\g; +---------+------------------------------------------------+ | Table | Create Table | +---------+------------------------------------------------+ | tb_emp1 | CREATE TABLE `tb_emp1` ( `id` int(11) DEFAULT NULL, `name` varchar(25) DEFAULT NULL, `salary` float DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=gb2312 | +---------+------------------------------------------------+ 1 row in set (0.00 sec) SHOW CREATE TABLE 使用\\G结尾的 SQL 语句和运行结果如下： mysql> SHOW CREATE TABLE tb_emp1\\G *************************** 1. row *************************** Table: tb_emp1 Create Table: CREATE TABLE `tb_emp1` ( `id` int(11) DEFAULT NULL, `name` varchar(25) DEFAULT NULL, `deptId` int(11) DEFAULT NULL, `salary` float DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=gb2312 1 row in set (0.03 sec) 参考： https://www.cnblogs.com/xiaohuochai/p/6081482.html Update time： 2020-08-18 "},"MySQL/MySQL基础/添加字段.html":{"url":"MySQL/MySQL基础/添加字段.html","title":"添加字段","keywords":"","body":"添加字段 数据表添加字段（三种方式） MySQL 数据表是由行和列构成的，通常把表的“列”称为字段（Field），把表的“行”称为记录（Record）。随着业务的变化，可能需要在已有的表中添加新的字段。 MySQL 允许在开头、中间和结尾处添加字段。 在末尾添加字段 一个完整的字段包括字段名、数据类型和约束条件。MySQL 添加字段的语法格式如下： ALTER TABLE ADD [约束条件]; 对语法格式的说明如下： 为数据表的名字； 为所要添加的字段的名字； 为所要添加的字段能存储数据的数据类型； [约束条件] 是可选的，用来对添加的字段进行约束。 这种语法格式默认在表的最后位置（最后一列的后面）添加新字段。 注意：本节我们只添加新的字段，不关注它的约束条件。 实例1 在 test 数据库中新建 student 数据表，SQL 语句和运行结果如下： mysql> USE test; Database changed mysql> CREATE TABLE student ( -> id INT(4), -> name VARCHAR(20), -> sex CHAR(1)); Query OK, 0 rows affected (0.09 sec) 使用 DESC 查看 student 表结构，SQL 语句和运行结果如下： mysql> DESC student; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | id | int(4) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | sex | char(1) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 3 rows in set (0.01 sec) 使用 ALTER TABLE 语句添加一个 INT 类型的字段 age，SQL 语句和运行结果如下： mysql> ALTER TABLE student ADD age INT(4); Query OK, 0 rows affected (0.16 sec) Records: 0 Duplicates: 0 Warnings: 0 使用 DESC 查看 student 表结构，检验 age 字段是否添加成功。SQL 语句和运行结果如下： mysql> DESC student; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | id | int(4) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | sex | char(1) | YES | | NULL | | | age | int(4) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 4 rows in set (0.00 sec) 由运行结果可以看到，student 表已经添加了 age 字段，且该字段在表的最后一个位置，添加字段成功。 在开头添加字段 MySQL 默认在表的最后位置添加新字段，如果希望在开头位置（第一列的前面）添加新字段，那么可以使用 FIRST 关键字，语法格式如下： ALTER TABLE ADD [约束条件] FIRST; FIRST 关键字一般放在语句的末尾。 实例2 使用 ALTER TABLE 语句在表的第一列添加 INT 类型的字段 stuId，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE student ADD stuId INT(4) FIRST; Query OK, 0 rows affected (0.14 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC student; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | stuId | int(4) | YES | | NULL | | | id | int(4) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | sex | char(1) | YES | | NULL | | | age | int(4) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 5 rows in set (0.00 sec) 由运行结果可以看到，student 表中已经添加了 stuId 字段，且该字段在表中的第一个位置，添加字段成功。 在中间位置添加字段 MySQL 除了允许在表的开头位置和末尾位置添加字段外，还允许在中间位置（指定的字段之后）添加字段，此时需要使用AFTER关键字，语法格式如下： ALTER TABLE ADD [约束条件] AFTER ; AFTER的作用是将新字段添加到某个已有字段后面。 注意，只能在某个已有字段的后面添加新字段，不能在它的前面添加新字段。 实例3 使用 ALTER TABLE 语句在 student 表中添加名为 stuno，数据类型为 INT 的字段，stuno 字段位于 name 字段的后面。SQL 语句和运行结果如下： mysql> ALTER TABLE student ADD stuno INT(11) AFTER name; Query OK, 0 rows affected (0.13 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC student; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | stuId | int(4) | YES | | NULL | | | id | int(4) | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | stuno | int(11) | YES | | NULL | | | sex | char(1) | YES | | NULL | | | age | int(4) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 6 rows in set (0.00 sec) 由运行结果可以看到，student 表中已经添加了 stuId 字段，且该字段在 name 字段后面的位置，添加字段成功。 修改/删除字段 修改字段名称 MySQL 中修改表字段名的语法规则如下： ALTER TABLE CHANGE ； 其中： 旧字段名：指修改前的字段名； 新字段名：指修改后的字段名； 新数据类型：指修改后的数据类型，如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样，但数据类型不能为空。 例 1 使用 ALTER TABLE 修改表 tb_emp1 的结构，将 col1 字段名称改为 col3，同时将数据类型变为 CHAR(30)，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE tb_emp1 -> CHANGE col1 col3 CHAR(30); Query OK, 0 rows affected (0.76 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC tb_emp1; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | col3 | char(30) | YES | | NULL | | | id | int(11) | YES | | NULL | | | name | varchar(30) | YES | | NULL | | | deptId | int(11) | YES | | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 5 rows in set (0.01 sec) CHANGE 也可以只修改数据类型，实现和 MODIFY 同样的效果，方法是将 SQL 语句中的“新字段名”和“旧字段名”设置为相同的名称，只改变“数据类型”。 提示：由于不同类型的数据在机器中的存储方式及长度并不相同，修改数据类型可能会影响数据表中已有的数据记录，因此，当数据表中已经有数据时，不要轻易修改数据类型。 修改字段数据类型 修改字段的数据类型就是把字段的数据类型转换成另一种数据类型。在 MySQL 中修改字段数据类型的语法规则如下： ALTER TABLE MODIFY 其中： 表名：指要修改数据类型的字段所在表的名称； 字段名：指需要修改的字段； 数据类型：指修改后字段的新数据类型。 例 2 使用 ALTER TABLE 修改表 tb_emp1 的结构，将 name 字段的数据类型由 VARCHAR(22) 修改成 VARCHAR(30)，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE tb_emp1 -> MODIFY name VARCHAR(30); Query OK, 0 rows affected (0.15 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC tb_emp1; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | col1 | int(11) | YES | | NULL | | | id | int(11) | YES | | NULL | | | name | varchar(30) | YES | | NULL | | | col2 | int(11) | YES | | NULL | | | deptId | int(11) | YES | | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 6 rows in set (0.00 sec) 语句执行后，发现表 tb_emp1 中 name 字段的数据类型已经修改成 VARCHAR(30)，修改成功。 删除字段 删除字段是将数据表中的某个字段从表中移除，语法格式如下： ALTER TABLE DROP ； 其中，“字段名”指需要从表中删除的字段的名称。 例 3 使用 ALTER TABLE 修改表 tb_emp1 的结构，删除 col2 字段，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE tb_emp1 -> DROP col2; Query OK, 0 rows affected (0.53 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC tb_emp1; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | col1 | int(11) | YES | | NULL | | | id | int(11) | YES | | NULL | | | name | varchar(30) | YES | | NULL | | | deptId | int(11) | YES | | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 5 rows in set (0.00 sec) Update time： 2020-09-20 "},"MySQL/MySQL基础/数据类型.html":{"url":"MySQL/MySQL基础/数据类型.html","title":"数据类型","keywords":"","body":"数据类型 数据表由多个字段组成，每个字段在进行数据定义的时候都要确定不同的数据类型。向每个字段插入的数据内容决定了该字段的数据类型。MySQL 提供了丰富的数据类型，根据实际需求，用户可以选择不同的数据类型。不同的数据类型，存储方式是不同的。 数据类型简介 数据类型（data_type）是指系统中所允许的数据的类型。MySQL 数据类型定义了列中可以存储什么数据以及该数据怎样存储的规则。 数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。例如，列中存储的为数字，则相应的数据类型应该为数值类型。 如果使用错误的数据类型可能会严重影响应用程序的功能和性能，所以在设计表时，应该特别重视数据列所用的数据类型。更改包含数据的列不是一件小事，这样做可能会导致数据丢失。因此，在创建表时必须为每个列设置正确的数据类型和长度。 MySQL 的数据类型有大概可以分为 5 种，分别是整数类型、浮点数类型和定点数类型、日期和时间类型、字符串类型、二进制类型等。 注意：整数类型和浮点数类型可以统称为数值数据类型。 1) 数值类型 整数类型包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，浮点数类型包括 FLOAT 和 DOUBLE，定点数类型为 DECIMAL。 2) 日期/时间类型 包括 YEAR、TIME、DATE、DATETIME 和 TIMESTAMP。 3) 字符串类型 包括 CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM 和 SET 等。 4) 二进制类型 包括 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。 定义字段的数据类型对数据库的优化是十分重要的。 整数类型 整数类型又称数值型数据，数值型数据类型主要用来存储数字。 MySQL 提供了多种数值型数据类型，不同的数据类型提供不同的取值范围，可以存储的值范围越大，所需的存储空间也会越大。 MySQL 主要提供的整数类型有 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，其属性字段可以添加 AUTO_INCREMENT 自增约束条件。下表中列出了 MySQL 中的数值类型。 类型名称 说明 存储需求 TINYINT 很小的整数 1个字节 SMALLINT 小的整数 2个宇节 MEDIUMINT 中等大小的整数 3个字节 INT (INTEGHR) 普通大小的整数 4个字节 BIGINT 大整数 8个字节 从上表中可以看到，不同类型的整数存储所需的字节数不相同，占用字节数最小的是 TINYINT 类型，占用字节最大的是 BIGINT 类型，占用的字节越多的类型所能表示的数值范围越大。 根据占用字节数可以求出每一种数据类型的取值范围。例如，TINYINT 需要 1 个字节（8bit）来存储，那么 TINYINT 无符号数的最大值为 28-1，即 255；TINYINT 有符号数的最大值为 27-1，即 127。其他类型的整数的取值范围计算方法相同，如下表所示。 类型名称 说明 存储需求 TINYINT -128〜127 0 〜255 SMALLINT -32768〜32767 0〜65535 MEDIUMINT -8388608〜8388607 0〜16777215 INT(INTEGER) -2147483648〜2147483647 0〜4294967295 BIGINT -9223372036854775808〜9223372036854775807 0〜18446744073709551615 提示：显示宽度和数据类型的取值范围是无关的。显示宽度只是指明 MySQL 最大可能显示的数字个数，数值的位数小于指定的宽度时会由空格填充。如果插入了大于显示宽度的值，只要该值不超过该类型整数的取值范围，数值依然可以插入，而且能够显示出来。例如，year 字段插入 19999，当使用 SELECT 查询该列值的时候，MySQL 显示的将是完整的带有 5 位数字的 19999，而不是 4 位数字的值。 其他整型数据类型也可以在定义表结构时指定所需的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值。 不同的整数类型有不同的取值范围，并且需要不同的存储空间，因此应根据实际需要选择最合适的类型，这样有利于提高查询的效率和节省存储空间。 小数类型 MySQL 中使用浮点数和定点数来表示小数。 浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL。 浮点类型和定点类型都可以用(M, D)来表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。 浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2），分别表示显示宽度和小数位数。M 和 D 在 FLOAT 和DOUBLE 中是可选的，FLOAT 和 DOUBLE 类型将被保存为硬件所支持的最大精度。DECIMAL 的默认 D 值为 0、M 值为 10。 下表中列出了 MySQL 中的小数类型和存储需求。 类型名称 说明 存储需求 FLOAT 单精度浮点数 4 个字节 DOUBLE 双精度浮点数 8 个字节 DECIMAL (M, D)，DEC 压缩的“严格”定点数 M+2 个字节 DECIMAL 类型不同于 FLOAT 和 DOUBLE。DOUBLE 实际上是以字符串的形式存放的，DECIMAL 可能的最大取值范围与 DOUBLE 相同，但是有效的取值范围由 M 和 D 决定。如果改变 M 而固定 D，则取值范围将随 M 的变大而变大。 从上表中可以看到，DECIMAL 的存储空间并不是固定的，而由精度值 M 决定，占用 M+2 个字节。 FLOAT 类型的取值范围如下： 有符号的取值范围：-3.402823466E+38～-1.175494351E-38。 无符号的取值范围：0 和 -1.175494351E-38～-3.402823466E+38。 DOUBLE 类型的取值范围如下： 有符号的取值范围：-1.7976931348623157E+308～-2.2250738585072014E-308。 无符号的取值范围：0 和 -2.2250738585072014E-308～-1.7976931348623157E+308。 提示：不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。 FLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。 浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的范围；缺点是会引起精度问题。 最后再强调一下：在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。 日期和时间类型 MySQL 中有多处表示日期的数据类型：YEAR、TIME、DATE、DTAETIME、TIMESTAMP。当只记录年信息的时候，可以只使用 YEAR 类型。 每一个类型都有合法的取值范围，当指定确定不合法的值时，系统将“零”值插入数据库中。 下表中列出了 MySQL 中的日期与时间类型。 类型名称 日期格式 日期范围 存储需求 YEAR YYYY 1901 ~ 2155 1 个字节 TIME HH:MM:SS -838:59:59 ~ 838:59:59 3 个字节 DATE YYYY-MM-DD 1000-01-01 ~ 9999-12-3 3 个字节 DATETIME YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 8 个字节 TIMESTAMP YYYY-MM-DD HH:MM:SS 1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC 4 个字节 YEAR 类型 YEAR 类型是一个单字节类型，用于表示年，在存储时只需要 1 个字节。可以使用各种格式指定 YEAR，如下所示： 以 4 位字符串或者 4 位数字格式表示的 YEAR，范围为 '1901'～'2155'。输入格式为 'YYYY' 或者 YYYY，例如，输入 '2010' 或 2010，插入数据库的值均为 2010。 以 2 位字符串格式表示的 YEAR，范围为 '00' 到 '99'。'00'～'69' 和 '70'～'99' 范围的值分别被转换为 2000～2069 和 1970～1999 范围的 YEAR 值。'0' 与 '00' 的作用相同。插入超过取值范围的值将被转换为 2000。 以 2 位数字表示的 YEAR，范围为 1～99。1～99 和 70～99 范围的值分别被转换为 2001～2069 和 1970～1999 范围的 YEAR 值。注意，在这里 0 值将被转换为 0000，而不是 2000。 提示：两位整数范围与两位字符串范围稍有不同。例如，插入 3000 年，读者可能会使用数字格式的 0 表示 YEAR，实际上，插入数据库的值为 0000，而不是所希望的 3000。只有使用字符串格式的 '0' 或 '00'，才可以被正确解释为 3000，非法 YEAR值将被转换为 0000。 TIME 类型 TIME 类型用于只需要时间信息的值，在存储时需要 3 个字节。格式为 HH:MM:SS。HH 表示小时，MM 表示分钟，SS 表示秒。 TIME 类型的取值范围为 -838：59：59～838：59：59，小时部分如此大的原因是 TIME 类型不仅可以用于表示一天的时间（必须小于 24 小时），还可能是某个事件过去的时间或两个事件之间的时间间隔（可大于 24 小时，或者甚至为负）。 可以使用各种格式指定 TIME 值，如下所示。 'D HH：MM：SS' 格式的字符串。还可以使用这些“非严格”的语法：'HH：MM：SS'、'HH：MM'、'D HH' 或 'SS'。这里的 D 表示日，可以取 0～34 之间的值。在插入数据库时，D 被转换为小时保存，格式为 “D*24+HH”。 'HHMMSS' 格式、没有间隔符的字符串或者 HHMMSS 格式的数值，假定是有意义的时间。例如，'101112' 被理解为'10：11：12'，但是 '106112' 是不合法的（它有一个没有意义的分钟部分），在存储时将变为 00：00：00。 提示：为 TIME 列分配简写值时应注意：如果没有冒号，MySQL 解释值时，假定最右边的两位表示秒。（MySQL 解释 TIME 值为过去的时间而不是当前的时间）。例如，读者可能认为 '1112' 和 1112 表示 11：12：00（即 11 点过 12 分钟），但MySQL 将它们解释为 00：11：12（即 11 分 12 秒）。同样 '12' 和 12 被解释为00：00：12。相反，TIME 值中如果使用冒号则肯定被看作当天的时间，也就是说，'11：12' 表示 11：12：00，而不是 00：11：12。 DATE 类型 DATE 类型用于仅需要日期值时，没有时间部分，在存储时需要 3 个字节。日期格式为 'YYYY-MM-DD'，其中 YYYY 表示年，MM 表示月，DD 表示日。 在给 DATE 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATE 的日期格式即可。如下所示： 以 'YYYY-MM-DD' 或者 'YYYYMMDD' 字符中格式表示的日期，取值范围为 '1000-01-01'～'9999-12-3'。例如，输入 '2015-12-31' 或者 '20151231'，插入数据库的日期为2015-12-31。 以 'YY-MM-DD' 或者 'YYMMDD' 字符串格式表示日期，在这里YY表示两位的年值。MySQL 解释两位年值的规则：'00～69' 范围的年值转换为 '2000~2069'，'70~99' 范围的年值转换为 '1970～1999'。例如，输入 '15-12-31'，插入数据库的日期为 2015-12-31；输入 '991231'，插入数据库的日期为 1999-12-31。 以 YYMMDD 数字格式表示的日期，与前面相似，00~69 范围的年值转换为 2000～2069，80～99 范围的年值转换为 1980～1999。例如，输入 151231，插入数据库的日期为 2015-12-31，输入 991231，插入数据库的日期为 1999-12-31。 使用 CURRENT_DATE 或者 NOW()，插入当前系统日期。 提示：MySQL 允许“不严格”语法：任何标点符号都可以用作日期部分之间的间隔符。例如，'98-11-31'、'98.11.31'、'98/11/31'和'98@11@31' 是等价的，这些值也可以正确地插入数据库。 DATETIME 类型 DATETIME 类型用于需要同时包含日期和时间信息的值，在存储时需要 8 个字节。日期格式为 'YYYY-MM-DD HH：MM：SS'，其中 YYYY 表示年，MM 表示月，DD 表示日，HH 表示小时，MM 表示分钟，SS 表示秒。 在给 DATETIME 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATETIME 的日期格式即可，如下所示。 以 'YYYY-MM-DD HH：MM：SS' 或者 'YYYYMMDDHHMMSS' 字符串格式表示的日期，取值范围为 '1000-01-01 00：00：00'～'9999-12-3 23：59：59'。例如，输入 '2014-12-31 05：05：05' 或者 '20141231050505’，插入数据库的 DATETIME 值都为 2014-12-31 05：05：05。 以 'YY-MM-DD HH：MM：SS' 或者 'YYMMDDHHMMSS' 字符串格式表示的日期，在这里 YY 表示两位的年值。与前面相同，'00～79' 范围的年值转换为 '2000～2079'，'80～99' 范围的年值转换为 '1980～1999'。例如，输入 '14-12-31 05：05：05'，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。 以 YYYYMMDDHHMMSS 或者 YYMMDDHHMMSS 数字格式表示的日期和时间。例如，输入 20141231050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05；输入 140505050505，插入数据库的 DATETIME 为 2014-12-31 05：05：05。 提示：MySQL 允许“不严格”语法：任何标点符号都可用作日期部分或时间部分之间的间隔符。例如，'98-12-31 11：30：45'、'98.12.31 11+30+35'、'98/12/31 113045' 和 '98@12@31 11^30^45' 是等价的，这些值都可以正确地插入数据库。 TIMESTAMP 类型 TIMESTAMP 的显示格式与 DATETIME 相同，显示宽度固定在 19 个字符，日期格式为 YYYY-MM-DD HH：MM：SS，在存储时需要 4 个字节。但是 TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，为 '1970-01-01 00：00：01'UTC～'2038-01-19 03：14：07'UTC。在插入数据时，要保证在合法的取值范围内。 提示：协调世界时（英：Coordinated Universal Time，法：Temps Universel Coordonné）又称为世界统一时间、世界标准时间、国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。 TIMESTAMP 与 DATETIME 除了存储字节和支持的范围不同外，还有一个最大的区别是： DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关； 而 TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。 提示：如果为一个 DATETIME 或 TIMESTAMP 对象分配一个 DATE 值，结果值的时间部分被设置为 '00：00：00'，因此 DATE 值未包含时间信息。如果为一个 DATE 对象分配一个 DATETIME 或 TIMESTAMP 值，结果值的时间部分被删除，因此DATE 值未包含时间信息。 字符串类型 字符串类型用来存储字符串数据，还可以存储图片和声音的二进制数据。字符串可以区分或者不区分大小写的串比较，还可以进行正则表达式的匹配查找。 MySQL 中的字符串类型有 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET 等。 下表中列出了 MySQL 中的字符串数据类型，括号中的M表示可以为其指定长度。 类型名称 说明 存储需求 CHAR(M) 固定长度非二进制字符串 M 字节，1 VARCHAR(M) 变长非二进制字符串 L+1字节，在此，L TINYTEXT 非常小的非二进制字符串 L+1字节，在此，L TEXT 小的非二进制字符串 L+2字节，在此，L MEDIUMTEXT 中等大小的非二进制字符串 L+3字节，在此，L LONGTEXT 大的非二进制字符串 L+4字节，在此，L ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目 (最大值为65535) SET 一个设置，字符串对象可以有零个或 多个SET成员 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） VARCHAR 和 TEXT 类型是变长类型，其存储需求取决于列值的实际长度（在前面的表格中用 L 表示），而不是取决于类型的最大可能尺寸。 例如，一个 VARCHAR(10) 列能保存一个最大长度为 10 个字符的字符串，实际的存储需要字符串的长度 L 加上一个字节以记录字符串的长度。对于字符 “abcd”，L 是 4，而存储要求 5 个字节。 CHAR 和 VARCHAR 类型 CHAR(M) 为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0～255 个字符。 例如，CHAR(4) 定义了一个固定长度的字符串列，包含的字符个数最大为 4。当检索到 CHAR 值时，尾部的空格将被删除。 VARCHAR(M) 是长度可变的字符串，M 表示最大列的长度，M 的范围是 0～65535。VARCHAR 的最大实际长度由最长的行的大小和使用的字符集确定，而实际占用的空间为字符串的实际长度加 1。 例如，VARCHAR(50) 定义了一个最大长度为 50 的字符串，如果插入的字符串只有 10 个字符，则实际存储的字符串为 10 个字符和一个字符串结束字符。VARCHAR 在值保存和检索时尾部的空格仍保留。 【实例】下面将不同的字符串保存到 CHAR(4) 和 VARCHAR(4) 列，说明 CHAR 和 VARCHAR 之间的差别，如下表所示。 插入值 CHAR(4) 存储需求 VARCHAR(4) 存储需求 ' ' ' ' 4字节 '' 1字节 'ab' 'ab ' 4字节 'ab' 3字节 'abc' 'abc ' 4字节 'abc' 4字节 'abcd' 'abcd' 4字节 'abcd' 5字节 'abcdef' 'abcd' 4字节 'abcd' 5字节 对比结果可以看到，CHAR(4) 定义了固定长度为 4 的列，无论存入的数据长度为多少，所占用的空间均为 4 个字节。VARCHAR(4) 定义的列所占的字节数为实际长度加 1。 TEXT 类型 TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。 TEXT 类型分为 4 种：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。 TINYTEXT 表示长度为 255（28-1）字符的 TEXT 列。 TEXT 表示长度为 65535（216-1）字符的 TEXT 列。 MEDIUMTEXT 表示长度为 16777215（224-1）字符的 TEXT 列。 LONGTEXT 表示长度为 4294967295 或 4GB（232-1）字符的 TEXT 列。 ENUM 类型 ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下： ENUM( '值1', '值1', …, '值n' ) 字段名指将要定义的字段，值 n 指枚举列表中第 n 个值。 ENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。 ENUM 值在内部用整数表示，每个枚举值均有一个索引值；列表值所允许的成员值从 1 开始编号，MySQL 存储的就是这个索引编号，枚举最多可以有 65535 个元素。 例如，定义 ENUM 类型的列（'first'，'second'，'third'），该列可以取的值和每个值的索引如下表所示。 值 索引 NULL NULL '' 0 first 1 second 2 third 3 ENUM 值依照列索引顺序排列，并且空字符串排在非空字符串前，NULL 值排在其他所有枚举值前。 提示：ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。 SET 类型 SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下： SET( '值1', '值2', …, '值n' ) 与 ENUM 类型相同，SET 值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET 成员值的尾部空格将自动删除。 但与 ENUM 类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而 SET 类型的列可从定义的列值中选择多个字符的联合。 提示：如果插入 SET 字段中的列值有重复，则 MySQL 自动删除重复的值；插入 SET 字段的值的顺序并不重要，MySQL 会在存入数据库时，按照定义的顺序显示；如果插入了不正确的值，默认情况下，MySQL 将忽视这些值，给出警告。 二进制类型 二进制字符串类型有时候也直接被称为“二进制类型”。 MySQL 中的二进制字符串有 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。 下表中列出了 MySQL 中的二进制数据类型，括号中的M表示可以为其指定长度。 类型名称 说明 存储需求 BIT(M) 位字段类型 大约 (M+7)/8 字节 BINARY(M) 固定长度二进制字符串 M 字节 VARBINARY (M) 可变长度二进制字符串 M+1 字节 TINYBLOB (M) 非常小的BLOB L+1 字节，在此，L BLOB (M) 小 BLOB L+2 字节，在此，L MEDIUMBLOB (M) 中等大小的BLOB L+3 字节，在此，L LONGBLOB (M) 非常大的BLOB L+4 字节，在此，L BIT 类型 位字段类型。M 表示每个值的位数，范围为 1～64。如果 M 被省略，默认值为 1。如果为 BIT(M) 列分配的值的长度小于 M 位，在值的左边用 0 填充。例如，为 BIT(6) 列分配一个值 b'101'，其效果与分配 b'000101' 相同。 BIT 数据类型用来保存位字段值，例如以二进制的形式保存数据 13，13 的二进制形式为 1101，在这里需要位数至少为 4 位的 BIT 类型，即可以定义列类型为 BIT(4)。大于二进制 1111 的数据是不能插入 BIT(4) 类型的字段中的。 提示：默认情况下，MySQL 不可以插入超出该列允许范围的值，因而插入数据时要确保插入的值在指定的范围内。 BINARY 和 VARBINARY 类型 BINARY 和 VARBINARY 类型类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字节字符串。使用的语法格式如下： 列名称 BINARY(M) 或者 VARBINARY(M) BINARY 类型的长度是固定的，指定长度后，不足最大长度的，将在它们右边填充 “\\0” 补齐，以达到指定长度。例如，指定列数据类型为 BINARY(3)，当插入 a 时，存储的内容实际为 “\\a0\\0”，当插入 ab 时，实际存储的内容为“ab\\0”，无论存储的内容是否达到指定的长度，存储空间均为指定的值 M。 VARBINARY 类型的长度是可变的，指定好长度之后，长度可以在 0 到最大值之间。例如，指定列数据类型为 VARBINARY(20)，如果插入的值长度只有 10，则实际存储空间为 10 加 1，实际占用的空间为字符串的实际长度加 1。 BLOB 类型 BLOB 是一个二进制的对象，用来存储可变数量的数据。BLOB 类型分为 4 种：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB，它们可容纳值的最大长度不同，如下表所示。 数据类型 存储范围 TINYBLOB 最大长度为255 (28-1)字节 BLOB 最大长度为65535 (216-1)字节 MEDIUMBLOB 最大长度为16777215 (224-1)字节 LONGBLOB 最大长度为4294967295或4GB (231-1)字节 BLOB 列存储的是二进制字符串（字节字符串），TEXT 列存储的是非进制字符串（字符字符串）。BLOB 列是字符集，并且排序和比较基于列值字节的数值；TEXT 列有一个字符集，并且根据字符集对值进行排序和比较。 转义字符的使用 在 MySQL 中，除了常见的字符之外，我们还会遇到一些特殊的字符，如换行符、回车符等。这些符号无法用字符来表示，因此需要使用某些特殊的字符来表示特殊的含义，这些字符就是转义字符。 转义字符一般以反斜杠符号\\开头，用来说明后面的字符不是字符本身的含义，而是表示其它的含义。MySQL 中常见的转义字符如下表所示。 转义字符 转义后的字符 \\\" 双引号（\"） \\' 单引号（'） \\ 反斜线（\\） \\n 换行符 \\r 回车符 \\t 制表符 \\0 ASCII 0（NUL） \\b 退格符 转义字符区分大小写，例如：'\\b' 解释为退格，但 '\\B' 解释为 'B'。 有以下几点需要注意： 字符串的内容包含单引号'时，可以用单引号'或反斜杠\\来转义。 字符串的内容包含双引号\"时，可以用双引号\"或反斜杠\\来转义。 一个字符串用双引号\"引用时，该字符串中的单引号'不需要特殊对待，且不必被重复转义。同理，一个字符串用单引号'引用时，该字符串中的双引号\"不需要特殊对待，且不必被重复转义。 例 1 下面通过 SELECT 语句演示单引号' 双引号\" 和反斜杠\\的使用： mysql> SELECT 'C语言中文网', '\"C语言中文网\"','\"\"C语言中文网\"\"','C语言''中文网', '\\'C语言中文网'; +-------------+---------------+-----------------+--------------+--------------+ | C语言中文网 | \"C语言中文网\" | \"\"C语言中文网\"\" | C语言'中文网 | 'C语言中文网 | +-------------+---------------+-----------------+--------------+--------------+ 1 row in set (0.07 sec) mysql> SELECT \"C语言中文网 \", \"'C语言中文网'\", \"''C语言中文网''\", \"C语言\"\"中文网\", \"\\\"C语言中文网\"; +--------------+---------------+-----------------+--------------+--------------+ | C语言中文网 | 'C语言中文网' | ''C语言中文网'' | C语言\"中文网 | \"C语言中文网 | +--------------+---------------+-----------------+--------------+--------------+ 1 row in set (0.00 sec) mysql> SELECT \"This\\nIs\\nC语言\\n中文网\"; +----------------------+ | This Is C语言 中文网 | +----------------------+ 1 row in set (0.00 sec) 如果你想要把二进制数据插入到一个 BLOB 列，下列字符必须使用反斜杠\\转义： NUL：ASCII 0。可以使用“\\0“表示。 \\：ASCII 92，反斜线。用“\\”表示。 ' ：ASCII 39，单引号。用“\\'”表示。 \" ：ASCII 34，双引号。用“\\\"”表示。 Update time： 2020-08-18 "},"MySQL/MySQL基础/MySQL 约束.html":{"url":"MySQL/MySQL基础/MySQL 约束.html","title":"MySQL 约束","keywords":"","body":"MySQL 约束 约束是一种限制，它通过限制表中的数据，来确保数据的完整性和唯一性。使用约束来限定表中的数据是很有必要的。 MySQL 提供了很多功能强大、使用方便的运算符和函数。我们可以通过使用这些运算符完成各种各样的运算操作。函数可以帮助开发人员简单、快速的编写 SQL 语句。 MySQL约束概述 在 MySQL 中，约束是指对表中数据的一种约束，能够帮助数据库管理员更好地管理数据库，并且能够确保数据库中数据的正确性和有效性。 例如，在数据表中存放年龄的值时，如果存入 200、300 这些无效的值就毫无意义了。因此，使用约束来限定表中的数据范围是很有必要的。 在 MySQL 中，主要支持以下 6 种约束： 1）主键约束 主键约束是使用最频繁的约束。在设计数据表时，一般情况下，都会要求表中设置一个主键。 主键是表的一个特殊字段，该字段能唯一标识该表中的每条信息。例如，学生信息表中的学号是唯一的。 2）外键约束 外键约束经常和主键约束一起使用，用来确保数据的一致性。 例如，一个水果摊，只有苹果、桃子、李子、西瓜 4 种水果，那么，你来到水果摊要买水果只能选择苹果、桃子、李子和西瓜，不能购买其它的水果。 3）唯一约束 唯一约束与主键约束有一个相似的地方，就是它们都能够确保列的唯一性。与主键约束不同的是，唯一约束在一个表中可以有多个，并且设置唯一约束的列是允许有空值的，虽然只能有一个空值。 例如，在用户信息表中，要避免表中的用户名重名，就可以把用户名列设置为唯一约束。 4）检查约束 检查约束是用来检查数据表中，字段值是否有效的一个手段。 例如，学生信息表中的年龄字段是没有负数的，并且数值也是有限制的。如果是大学生，年龄一般应该在 18~30 岁之间。在设置字段的检查约束时要根据实际情况进行设置，这样能够减少无效数据的输入。 5）非空约束 非空约束用来约束表中的字段不能为空。例如，在学生信息表中，如果不添加学生姓名，那么这条记录是没有用的。 6）默认值约束 默认值约束用来约束当数据表中某个字段不输入值时，自动为其添加一个已经设置好的值。 例如，在注册学生信息时，如果不输入学生的性别，那么会默认设置一个性别或者输入一个“未知”。 默认值约束通常用在已经设置了非空约束的列，这样能够防止数据表在录入数据时出现错误。 以上 6 种约束中，一个数据表中只能有一个主键约束，其它约束可以有多个。 主键（PRIMARY KEY） 主键（PRIMARY KEY）的完整称呼是“主键约束”，是 MySQL 中使用最为频繁的约束。一般情况下，为了便于 DBMS 更快的查找到表中的记录，都会在表中设置一个主键。 主键分为单字段主键和多字段联合主键，本节将分别讲解这两种主键约束的创建、修改和删除。 使用主键应注意以下几点： 每个表只能定义一个主键。 主键值必须唯一标识表中的每一行，且不能为 NULL，即表中不可能存在有相同主键值的两行数据。这是唯一性原则。 一个字段名只能在联合主键字段表中出现一次。 联合主键不能包含不必要的多余字段。当把联合主键的某一字段删除后，如果剩下的字段构成的主键仍然满足唯一性原则，那么这个联合主键是不正确的。这是最小化原则。 在创建表时设置主键约束 在创建数据表时设置主键约束，既可以为表中的一个字段设置主键，也可以为表中多个字段设置联合主键。但是不论使用哪种方法，在一个表中主键只能有一个。下面分别讲解设置单字段主键和多字段联合主键的方法。 1）设置单字段主键 在 CREATE TABLE 语句中，通过 PRIMARY KEY 关键字来指定主键。 在定义字段的同时指定主键，语法格式如下： PRIMARY KEY [默认值] 例 1 在 test_db 数据库中创建 tb_emp3 数据表，其主键为 id，SQL 语句和运行结果如下。 mysql> CREATE TABLE tb_emp3 -> ( -> id INT(11) PRIMARY KEY, -> name VARCHAR(25), -> deptId INT(11), -> salary FLOAT -> ); Query OK, 0 rows affected (0.37 sec) mysql> DESC tb_emp3; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(25) | YES | | NULL | | | deptId | int(11) | YES | | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 4 rows in set (0.14 sec) 或者是在定义完所有字段之后指定主键，语法格式如下： [CONSTRAINT ] PRIMARY KEY [字段名] 例 2 在 test_db 数据库中创建 tb_emp4 数据表，其主键为 id，SQL 语句和运行结果如下。 mysql> CREATE TABLE tb_emp4 -> ( -> id INT(11), -> name VARCHAR(25), -> deptId INT(11), -> salary FLOAT, -> PRIMARY KEY(id) -> ); Query OK, 0 rows affected (0.37 sec) mysql> DESC tb_emp4; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(25) | YES | | NULL | | | deptId | int(11) | YES | | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 4 rows in set (0.14 sec) 2）在创建表时设置联合主键 所谓的联合主键，就是这个主键是由一张表中多个字段组成的。 比如，设置学生选课数据表时，使用学生编号做主键还是用课程编号做主键呢？如果用学生编号做主键，那么一个学生就只能选择一门课程。如果用课程编号做主键，那么一门课程只能有一个学生来选。显然，这两种情况都是不符合实际情况的。 实际上设计学生选课表，要限定的是一个学生只能选择同一课程一次。因此，学生编号和课程编号可以放在一起共同作为主键，这也就是联合主键了。 主键由多个字段联合组成，语法格式如下： PRIMARY KEY [字段1，字段2，…,字段n] 注意：当主键是由多个字段组成时，不能直接在字段名后面声明主键约束。 例 3 创建数据表 tb_emp5，假设表中没有主键 id，为了唯一确定一个员工，可以把 name、deptId 联合起来作为主键，SQL 语句和运行结果如下。 mysql> CREATE TABLE tb_emp5 -> ( -> name VARCHAR(25), -> deptId INT(11), -> salary FLOAT, -> PRIMARY KEY(id,deptId) -> ); Query OK, 0 rows affected (0.37 sec) mysql> DESC tb_emp5; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | name | varchar(25) | NO | PRI | NULL | | | deptId | int(11) | NO | PRI | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 3 rows in set (0.14 sec) 在修改表时添加主键约束 主键约束不仅可以在创建表的同时创建，也可以在修改表时添加。但是需要注意的是，设置成主键约束的字段中不允许有空值。 在修改数据表时添加主键约束的语法格式如下： ALTER TABLE ADD PRIMARY KEY(); 查看 tb_emp2 数据表的表结构，SQL 语句和运行结果如下所示。 mysql> DESC tb_emp2; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | id | int(11) | NO | | NULL | | | name | varchar(30) | YES | | NULL | | | deptId | int(11) | YES | | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 4 rows in set (0.14 sec) 例 4 修改数据表 tb_emp2，将字段 id 设置为主键，SQL 语句和运行结果如下。 mysql> ALTER TABLE tb_emp2 -> ADD PRIMARY KEY(id); Query OK, 0 rows affected (0.94 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC tb_emp2; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(30) | YES | | NULL | | | deptId | int(11) | YES | | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 4 rows in set (0.12 sec) 通常情况下，当在修改表时要设置表中某个字段的主键约束时，要确保设置成主键约束的字段中值不能够有重复的，并且要保证是非空的。否则，无法设置主键约束。 删除主键约束 当一个表中不需要主键约束时，就需要从表中将其删除。删除主键约束的方法要比创建主键约束容易的多。 删除主键约束的语法格式如下所示： ALTER TABLE DROP PRIMARY KEY; 例 5 删除 tb_emp2 表中的主键约束，SQL 语句和运行结果如下。 mysql> ALTER TABLE tb_emp2 -> DROP PRIMARY KEY; Query OK, 0 rows affected (0.94 sec) Records: 0 Duplicates: 0 Warnings: 0 由于主键约束在一个表中只能有一个，因此不需要指定主键名就可以删除一个表中的主键约束。 AUTO_INCREMENT：主键自增长 在 MySQL 中，当主键定义为自增长后，这个主键的值就不再需要用户输入数据了，而由数据库系统根据定义自动赋值。每增加一条记录，主键会自动以相同的步长进行增长。 通过给字段添加 AUTO_INCREMENT 属性来实现主键自增长。语法格式如下： 字段名 数据类型 AUTO_INCREMENT 默认情况下，AUTO_INCREMENT 的初始值是 1，每新增一条记录，字段值自动加 1。 一个表中只能有一个字段使用 AUTO_INCREMENT 约束，且该字段必须有唯一索引，以避免序号重复（即为主键或主键的一部分）。 AUTO_INCREMENT 约束的字段必须具备 NOT NULL 属性。 AUTO_INCREMENT 约束的字段只能是整数类型（TINYINT、SMALLINT、INT、BIGINT 等）。 AUTO_INCREMENT 约束字段的最大值受该字段的数据类型约束，如果达到上限，AUTO_INCREMENT 就会失效。 例 1 定义数据表 tb_student，指定表中 id 字段递增，SQL 语句和运行结果如下： mysql> CREATE TABLE tb_student( -> id INT(4) PRIMARY KEY AUTO_INCREMENT, -> name VARCHAR(25) NOT NULL -> ); Query OK, 0 rows affected (0.07 sec) 上述语句执行成功后，会创建名为 tb_student 的数据表。其中，id 为主键，每插入一条新记录，id 的值就会在前一条记录的基础上自动加 1。name 为非空字段，该字段的值不能为空值（NULL）。 向 tb_student 表中插入数据，SQL 语句如下所示： INSERT INTO tb_student(name) VALUES('Java')('MySQL')('Python'); 语句执行完后，tb_student 表中增加了 3 条记录，在这里并没有输入 id 的值，但系统已经自动添加该值，使用 SELECT 命令查看记录，如下所示。 mysql> SELECT * FROM tb_student; +----+--------+ | id | name | +----+--------+ | 1 | Java | | 2 | MySQL | | 3 | Python | +----+--------+ 4 rows in set (0.01 sec) 拓展 加上 AUTO_INCREMENT 约束条件后，字段中的每个值都是自动增加的。因此，这个字段不可能出现相同的值。通常情况下，AUTO_INCREMENT 都是作为 id 字段的约束条件，并且将 id 字段作为表的主键。 指定自增字段初始值 如果第一条记录设置了该字段的初始值，那么新增加的记录就从这个初始值开始自增。例如，如果表中插入的第一条记录的 id 值设置为 5，那么再插入记录时，id 值就会从 5 开始往上增加。 例 2 下面创建表 tb_student2，指定主键从 100 开始自增长。SQL 语句和运行结果如下： mysql> CREATE TABLE tb_student2 ( -> id INT NOT NULL AUTO_INCREMENT, -> name VARCHAR(20) NOT NULL, -> PRIMARY KEY(ID) -> )AUTO_INCREMENT=100; Query OK, 0 rows affected (0.03 sec) 向 tb_student2 表中插入数据，并使用 SELECT 命令查询表中记录。 mysql> INSERT INTO tb_student2 (name)VALUES('Java'); Query OK, 1 row affected (0.07 sec) mysql> SELECT * FROM tb_student2; +-----+------+ | id | name | +-----+------+ | 100 | Java | +-----+------+ 由结果可以看出，id 值从 100 开始自动增长。 自增字段值不连续 下面我们通过一个实例分析自增字段的值为什么不连续。 例 3 创建表 tb_student3，其中 id 是自增主键字段，name 是唯一索引，SQL 语句和执行结果语句如下： mysql> CREATE TABLE tb_student3( -> id INT PRIMARY KEY AUTO_INCREMENT, -> name VARCHAR(20) UNIQUE KEY, -> age INT DEFAULT NULL -> ); Query OK, 0 rows affected (0.04 sec) 向 tb_student3 表中插入数据，SQL 语句如下： INSERT INTO tb_student3 VALUES(1,1,1); 此时，表 tb_student3 中已经有了（1,1,1）这条记录，这时再执行一条插入数据命令： mysql> INSERT INTO tb_student3 VALUES(null,1,1); ERROR 1062 (23000): Duplicate entry '1' for key 'name' 由于表中已经存在 name=1 的记录，所以报 Duplicate key error（唯一键冲突）。在这之后，再插入新的数据时，自增 id 就是 3，这样就出现了自增字段值不连续的情况。 外键约束（FOREIGN KEY） MySQL 外键约束（FOREIGN KEY）是表的一个特殊字段，经常与主键约束一起使用。对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表（父表），外键所在的表就是从表（子表）。 外键用来建立主表与从表的关联关系，为两个表的数据建立连接，约束两个表中数据的一致性和完整性。比如，一个水果摊，只有苹果、桃子、李子、西瓜等 4 种水果，那么，你来到水果摊要买水果就只能选择苹果、桃子、李子和西瓜，其它的水果都是不能购买的。 主表删除某条记录时，从表中与之对应的记录也必须有相应的改变。一个表可以有一个或多个外键，外键可以为空值，若不为空值，则每一个外键的值必须等于主表中主键的某个值。 定义外键时，需要遵守下列规则： 主表必须已经存在于数据库中，或者是当前正在创建的表。如果是后一种情况，则主表与从表是同一个表，这样的表称为自参照表，这种结构称为自参照完整性。 必须为主表定义主键。 主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。 在主表的表名后面指定列名或列名的组合。这个列或列的组合必须是主表的主键或候选键。 外键中列的数目必须和主表的主键中列的数目相同。 外键中列的数据类型必须和主表主键中对应列的数据类型相同。 在创建表时设置外键约束 在 CREATE TABLE 语句中，通过 FOREIGN KEY 关键字来指定外键，具体的语法格式如下： [CONSTRAINT ] FOREIGN KEY 字段名 [，字段名2，…] REFERENCES 主键列1 [，主键列2，…] 例 1 为了展现表与表之间的外键关系，本例在 test_db 数据库中创建一个部门表 tb_dept1，表结构如下表所示。 字段名称 数据类型 备注 id INT(11) 部门编号 name VARCHAR(22) 部门名称 location VARCHAR(22) 部门位置 创建 tb_dept1 的 SQL 语句和运行结果如下所示。 mysql> CREATE TABLE tb_dept1 -> ( -> id INT(11) PRIMARY KEY, -> name VARCHAR(22) NOT NULL, -> location VARCHAR(50) -> ); Query OK, 0 rows affected (0.37 sec) 创建数据表 tb_emp6，并在表 tb_emp6 上创建外键约束，让它的键 deptId 作为外键关联到表 tb_dept1 的主键 id，SQL 语句和运行结果如下所示。 mysql> CREATE TABLE tb_emp6 -> ( -> id INT(11) PRIMARY KEY, -> name VARCHAR(25), -> deptId INT(11), -> salary FLOAT, -> CONSTRAINT fk_emp_dept1 -> FOREIGN KEY(deptId) REFERENCES tb_dept1(id) -> ); Query OK, 0 rows affected (0.37 sec) mysql> DESC tb_emp6; +--------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+-------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(25) | YES | | NULL | | | deptId | int(11) | YES | MUL | NULL | | | salary | float | YES | | NULL | | +--------+-------------+------+-----+---------+-------+ 4 rows in set (1.33 sec) 以上语句执行成功之后，在表 tb_emp6 上添加了名称为 fk_emp_dept1 的外键约束，外键名称为 deptId，其依赖于表 tb_dept1 的主键 id。 注意：从表的外键关联的必须是主表的主键，且主键和外键的数据类型必须一致。例如，两者都是 INT 类型，或者都是 CHAR 类型。如果不满足这样的要求，在创建从表时，就会出现“ERROR 1005(HY000): Can't create table”错误。 在修改表时添加外键约束 外键约束也可以在修改表时添加，但是添加外键约束的前提是：从表中外键列中的数据必须与主表中主键列中的数据一致或者是没有数据。 在修改数据表时添加外键约束的语法格式如下： ALTER TABLE ADD CONSTRAINT FOREIGN KEY() REFERENCES (); 例 2 修改数据表 tb_emp2，将字段 deptId 设置为外键，与数据表 tb_dept1 的主键 id 进行关联，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE tb_emp2 -> ADD CONSTRAINT fk_tb_dept1 -> FOREIGN KEY(deptId) -> REFERENCES tb_dept1(id); Query OK, 0 rows affected (1.38 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> SHOW CREATE TABLE tb_emp2\\G *************************** 1. row *************************** Table: tb_emp2 Create Table: CREATE TABLE `tb_emp2` ( `id` int(11) NOT NULL, `name` varchar(30) DEFAULT NULL, `deptId` int(11) DEFAULT NULL, `salary` float DEFAULT NULL, PRIMARY KEY (`id`), KEY `fk_tb_dept1` (`deptId`), CONSTRAINT `fk_tb_dept1` FOREIGN KEY (`deptId`) REFERENCES `tb_dept1` (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=gb2312 1 row in set (0.12 sec) 注意：在为已经创建好的数据表添加外键约束时，要确保添加外键约束的列的值全部来源于主键列，并且外键列不能为空。 删除外键约束 当一个表中不需要外键约束时，就需要从表中将其删除。外键一旦删除，就会解除主表和从表间的关联关系。 删除外键约束的语法格式如下所示： ALTER TABLE DROP FOREIGN KEY ; 例 3 删除数据表 tb_emp2 中的外键约束 fk_tb_dept1，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE tb_emp2 -> DROP FOREIGN KEY fk_tb_dept1; Query OK, 0 rows affected (0.19 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> SHOW CREATE TABLE tb_emp2\\G *************************** 1. row *************************** Table: tb_emp2 Create Table: CREATE TABLE `tb_emp2` ( `id` int(11) NOT NULL, `name` varchar(30) DEFAULT NULL, `deptId` int(11) DEFAULT NULL, `salary` float DEFAULT NULL, PRIMARY KEY (`id`), KEY `fk_tb_dept1` (`deptId`) ) ENGINE=InnoDB DEFAULT CHARSET=gb2312 1 row in set (0.00 sec) 可以看到，tb_emp2 中已经不存在 FOREIGN KEY，原有的名称为 fk_emp_dept 的外键约束删除成功。 唯一约束（UNIQUE KEY） MySQL 唯一约束（Unique Key）是指所有记录中字段的值不能重复出现。 例如，为 id 字段加上唯一性约束后，每条记录的 id 值都是唯一的，不能出现重复的情况。如果其中一条记录的 id 值为‘0001’，那么该表中就不能出现另一条记录的 id 值也为‘0001’。 唯一约束与主键约束相似的是它们都可以确保列的唯一性。不同的是，唯一约束在一个表中可有多个，并且设置唯一约束的列允许有空值，但是只能有一个空值。而主键约束在一个表中只能有一个，且不允许有空值。比如，在用户信息表中，为了避免表中用户名重名，可以把用户名设置为唯一约束。 在创建表时设置唯一约束 唯一约束可以在创建表时直接设置，通常设置在除了主键以外的其它列上。 在定义完列之后直接使用 UNIQUE 关键字指定唯一约束，语法格式如下： UNIQUE 例 1 创建数据表 tb_dept2，指定部门的名称唯一，SQL 语句和运行结果如下所示。 mysql> CREATE TABLE tb_dept2 -> ( -> id INT(11) PRIMARY KEY, -> name VARCHAR(22) UNIQUE, -> location VARCHAR(50) -> ); Query OK, 0 rows affected (0.37 sec) mysql> DESC tb_dept2; +----------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(40) | YES | UNI | NULL | | | location | varchar(50) | YES | | NULL | | +----------+-------------+------+-----+---------+-------+ 3 rows in set (0.08 sec) 在修改表时添加唯一约束 在修改表时添加唯一约束的语法格式为： ALTER TABLE ADD CONSTRAINT UNIQUE(); 例 2 修改数据表 tb_dept1，指定部门的名称唯一，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE tb_dept1 -> ADD CONSTRAINT unique_name UNIQUE(name); Query OK, 0 rows affected (0.63 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC tb_dept1; +----------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(22) | NO | UNI | NULL | | | location | varchar(50) | YES | | NULL | | +----------+-------------+------+-----+---------+-------+ 3 rows in set (0.00 sec) 删除唯一约束 在 MySQL 中删除唯一约束的语法格式如下： ALTER TABLE DROP INDEX ; 例 3 删除数据表 tb_dept1 中的唯一约束 unique_name，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE tb_dept1 -> DROP INDEX unique_name; Query OK, 0 rows affected (0.20 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC tb_dept1; +----------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(22) | NO | | NULL | | | location | varchar(50) | YES | | NULL | | +----------+-------------+------+-----+---------+-------+ 3 rows in set (0.00 sec) 检查约束（CHECK） MySQL 检查约束（CHECK）是用来检查数据表中字段值有效性的一种手段，可以通过 CREATE TABLE 或 ALTER TABLE 语句实现。设置检查约束时要根据实际情况进行设置，这样能够减少无效数据的输入。 选取设置检查约束的字段 检查约束使用 CHECK 关键字，具体的语法格式如下： CHECK 其中，“表达式”指的就是 SQL 表达式，用于指定需要检查的限定条件。 若将 CHECK 约束子句置于表中某个列的定义之后，则这种约束也称为基于列的 CHECK 约束。 在更新表数据的时候，系统会检查更新后的数据行是否满足 CHECK 约束中的限定条件。MySQL 可以使用简单的表达式来实现 CHECK 约束，也允许使用复杂的表达式作为限定条件，例如在限定条件中加入子查询。 注意：若将 CHECK 约束子句置于所有列的定义以及主键约束和外键定义之后，则这种约束也称为基于表的 CHECK 约束。该约束可以同时对表中多个列设置限定条件。 在创建表时设置检查约束 一般情况下，如果系统的表结构已经设计完成，那么在创建表时就可以为字段设置检查约束了。 创建表时设置检查约束的语法格式如下： CHECK() 例 1 在 test_db 数据库中创建 tb_emp7 数据表，要求 salary 字段值大于 0 且小于 10000，SQL 语句和运行结果如下所示。 mysql> CREATE TABLE tb_emp7 -> ( -> id INT(11) PRIMARY KEY, -> name VARCHAR(25), -> deptId INT(11), -> salary FLOAT, -> CHECK(salary>0 AND salary FOREIGN KEY(deptId) REFERENCES tb_dept1(id) -> ); Query OK, 0 rows affected (0.37 sec) 在修改表时添加检查约束 如果一个表创建完成，可以通过修改表的方式为表添加检查约束。 修改表时设置检查约束的语法格式如下： ALTER TABLE tb_emp7 ADD CONSTRAINT CHECK() 例 2 修改 tb_emp7 数据表，要求 id 字段值大于 0，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE tb_emp7 -> ADD CONSTRAINT check_id -> CHECK(id>0); Query OK, 0 rows affected (0.19 sec) Records: 0 Duplicates: 0 Warnings: 0 删除检查约束 修改表时删除检查约束的语法格式如下： ALTER TABLE DROP CONSTRAINT ; 例 3 删除 tb_emp7 表中的 check_id 检查约束，SQL 语句和运行结果如下所示： mysql> ALTER TABLE tb_emp7 -> DROP CONSTRAINT check_id; Query OK, 0 rows affected (0.19 sec) Records: 0 Duplicates: 0 Warnings: 0 默认值（DEFAULT） 默认值（Default）的完整称呼是“默认值约束（Default Constraint）”，用来指定某列的默认值。在表中插入一条新记录时，如果没有为某个字段赋值，系统就会自动为这个字段插入默认值。 例如，员工信息表中，部门位置在北京的较多，那么部门位置就可以默认为“北京”，系统就会自动为这个字段赋值为“北京”。 默认值约束通常用在已经设置了非空约束的列，这样能够防止数据表在录入数据时出现错误。 在创建表时设置默认值约束 创建表时可以使用 DEFAULT 关键字设置默认值约束，具体的语法格式如下： DEFAULT ; 其中，“默认值”为该字段设置的默认值，如果是字符类型的，要用单引号括起来。 例 1 创建数据表 tb_dept3，指定部门位置默认为 Beijing，SQL 语句和运行结果如下所示。 mysql> CREATE TABLE tb_dept3 -> ( -> id INT(11) PRIMARY KEY, -> name VARCHAR(22), -> location VARCHAR(50) DEFAULT 'Beijing' -> ); Query OK, 0 rows affected (0.37 sec) mysql> DESC tb_dept3; +----------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(22) | YES | | NULL | | | location | varchar(50) | YES | | Beijing | | +----------+-------------+------+-----+---------+-------+ 3 rows in set (0.06 sec) 以上语句执行成功之后，表 tb_dept3 上的字段 location 拥有了一个默认值 Beijing，新插入的记录如果没有指定部门位置，则默认都为 Beijing。 注意：在创建表时为列添加默认值，可以一次为多个列添加默认值，需要注意不同列的数据类型。 在修改表时添加默认值约束 修改表时添加默认值约束的语法格式如下： ALTER TABLE CHANGE COLUMN DEFAULT ; 例 2 修改数据表 tb_dept3，将部门位置的默认值修改为 Shanghai，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE tb_dept3 -> CHANGE COLUMN location -> location VARCHAR(50) DEFAULT 'Shanghai'; Query OK, 0 rows affected (0.15 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC tb_dept3; +----------+-------------+------+-----+----------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+----------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(22) | YES | | NULL | | | location | varchar(50) | YES | | Shanghai | | +----------+-------------+------+-----+----------+-------+ 3 rows in set (0.00 sec) 删除默认值约束 当一个表中的列不需要设置默认值时，就需要从表中将其删除。 修改表时删除默认值约束的语法格式如下： ALTER TABLE CHANGE COLUMN DEFAULT NULL; 例 3 修改数据表 tb_dept3，将部门位置的默认值约束删除，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE tb_dept3 -> CHANGE COLUMN location -> location VARCHAR(50) DEFAULT NULL; Query OK, 0 rows affected (0.15 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC tb_dept3; +----------+-------------+------+-----+----------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+----------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(22) | YES | | NULL | | | location | varchar(50) | YES | | NULL | | +----------+-------------+------+-----+----------+-------+ 3 rows in set (0.00 sec) 非空约束（NOT NULL） MySQL 非空约束（NOT NULL）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。可以通过 CREATE TABLE 或 ALTER TABLE 语句实现。在表中某个列的定义后加上关键字 NOT NULL作为限定词，来约束该列的取值不能为空。 比如，在用户信息表中，如果不添加用户名，那么这条用户信息就是无效的，这时就可以为用户名字段设置非空约束。 在创建表时设置非空约束 创建表时可以使用 NOT NULL 关键字设置非空约束，具体的语法格式如下： NOT NULL; 例 1 创建数据表 tb_dept4，指定部门名称不能为空，SQL 语句和运行结果如下所示。 mysql> CREATE TABLE tb_dept4 -> ( -> id INT(11) PRIMARY KEY, -> name VARCHAR(22) NOT NULL, -> location VARCHAR(50) -> ); Query OK, 0 rows affected (0.37 sec) mysql> DESC tb_dept3; +----------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+---------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(22) | NO | | NULL | | | location | varchar(50) | YES | | NULL | | +----------+-------------+------+-----+---------+-------+ 3 rows in set (0.06 sec) 在修改表时添加非空约束 如果在创建表时忘记了为字段设置非空约束，也可以通过修改表进行非空约束的添加。 修改表时设置非空约束的语法格式如下： ALTER TABLE CHANGE COLUMN NOT NULL; 例 2 修改数据表 tb_dept4，指定部门位置不能为空，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE tb_dept4 -> CHANGE COLUMN location -> location VARCHAR(50) NOT NULL; Query OK, 0 rows affected (0.15 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC tb_dept4; +----------+-------------+------+-----+----------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+----------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(22) | NO | | NULL | | | location | varchar(50) | NO | | NULL | | +----------+-------------+------+-----+----------+-------+ 3 rows in set (0.00 sec) 删除非空约束 修改表时删除非空约束的语法规则如下： ALTER TABLE CHANGE COLUMN NULL; 例 3 修改数据表 tb_dept4，将部门位置的非空约束删除，SQL 语句和运行结果如下所示。 mysql> ALTER TABLE tb_dept4 -> CHANGE COLUMN location -> location VARCHAR(50) NULL; Query OK, 0 rows affected (0.15 sec) Records: 0 Duplicates: 0 Warnings: 0 mysql> DESC tb_dept4; +----------+-------------+------+-----+----------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-------------+------+-----+----------+-------+ | id | int(11) | NO | PRI | NULL | | | name | varchar(22) | NO | | NULL | | | location | varchar(50) | YES | | NULL | | +----------+-------------+------+-----+----------+-------+ 3 rows in set (0.00 sec) 查看表中的约束 在 MySQL 中可以使用 SHOW CREATE TABLE 语句来查看表中的约束。 查看数据表中的约束语法格式如下： SHOW CREATE TABLE ; 例 1 创建数据表 tb_emp8 并指定 id 为主键约束，name 为唯一约束，deptId 为非空约束和外键约束，然后查看表中的约束，SQL 语句运行结果如下。 mysql> CREATE TABLE tb_emp8 -> ( -> id INT(11) PRIMARY KEY, -> name VARCHAR(22) UNIQUE, -> deptId INT(11) NOT NULL, -> salary FLOAT DEFAULT 0, -> CHECK(salary>0), -> FOREIGN KEY(deptId) REFERENCES tb_dept1(id) -> ); Query OK, 0 rows affected (0.37 sec) mysql> SHOW CREATE TABLE tb_emp8 \\G *************************** 1. row *************************** Table: tb_emp8 Create Table: CREATE TABLE `tb_emp8` ( `id` int(11) NOT NULL, `name` varchar(22) DEFAULT NULL, `deptId` int(11) NOT NULL, `salary` float DEFAULT '0', PRIMARY KEY (`id`), UNIQUE KEY `name` (`name`), KEY `deptId` (`deptId`), CONSTRAINT `tb_emp8_ibfk_1` FOREIGN KEY (`deptId`) REFERENCES `tb_dept1` (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=gb2312 1 row in set (0.19 sec) Update time： 2020-08-19 "},"MySQL/MySQL基础/索引的创建与使用.html":{"url":"MySQL/MySQL基础/索引的创建与使用.html","title":"索引的创建与使用","keywords":"","body":"索引的创建与使用 什么是索引？ 索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B-树的形式保存。如果没有索引，执行查询时MySQL必须从第一个记录开始扫描整个表的所有记录，直至找到符合要求的记录。表里面的记录数量越多，这个操作的代价就越高。如果作为搜索条件的列上已经创建了索引，MySQL无需扫描任何记录即可迅速得到目标记录所在的位置。如果表有1000个记录，通过索引查找记录至少要比顺序扫描记录快100倍。 MySQL中可以使用alter table这个SQL语句来为表中的字段添加索引。 使用ALTER TABLE语句创建索性 应用于表创建完毕之后再添加。 添加PRIMARY KEY（主键索引） alter table 'tablename' add primary key('column_name') 添加UNIQUE(唯一索引) alter table 'table_name' add unique index index_name ('column_list') 添加 index (普通索引) alter table 'table_name' add index index_name('column_list') 例子： ALTER table t_debt_loan_log ADD INDEX debt_no ( `debt_no` ) 添加多列索引 ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` ) 添加FULLTEXT(全文索引) ALTER TABLE `table_name` ADD FULLTEXT index index_name ( `column`) ALTER TABLE可用于创建普通索引、UNIQUE索引和PRIMARY KEY索引3种索引格式，table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。索引名index_name可选，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以同时创建多个索引。 使用CREATE INDEX语句对表增加索引 CREATE INDEX可用于对表增加普通索引或UNIQUE索引，可用于建表时创建索引。 CREATE INDEX index_name ON table_name(username(length)); 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。 //create只能添加这两种索引; CREATE INDEX index_name ON table_name (column_list) CREATE UNIQUE INDEX index_name ON table_name (column_list) table_name、index_name和column_list具有与ALTER TABLE语句中相同的含义，索引名不可选。另外，不能用CREATE INDEX语句创建PRIMARY KEY索引。 索引所用的算法 唯一索引和普通索引使用的结构都是B-tree,执行时间复杂度都是O(log n)。 补充下概念： 1、普通索引 　　普通索引（由关键字KEY或INDEX定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHEREcolumn=）或排序条件（ORDERBYcolumn）中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列（如一个整数类型的数据列）来创建索引。 2、唯一索引 　　普通索引允许被索引的数据列包含重复的值。比如说，因为人有可能同名，所以同一个姓名在同一个“员工个人资料”数据表里可能出现两次或更多次。 如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。这么做的好处：一是简化了MySQL对这个索引的管理工作，这个索引也因此而变得更有效率；二是MySQL会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是，MySQL将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。 3、注意 经过实践发现，不要以为WHERE中的字段顺序无所谓，可以随便放在哪，应该尽可能地第一次就过滤掉大部分无用的数据，只返回最小范围的数据。 索引的使用及注意事项 EXPLAIN可以帮助开发人员分析SQL问题, explain显示了 mysql如何使用索引来处理select语句以及连接表,可以帮助选择更好的索引和写出更优化的查询语句。 使用方法,在select语句前加上Explain就可以了： Explain select * from user where id=1; 尽量避免这些不走索引的sql： SELECT `sname` FROM `stu` WHERE `age`+10=30;-- 不会使用索引,因为所有索引列参与了计算 SELECT `sname` FROM `stu` WHERE LEFT(`date`,4) 　索引虽然好处很多，但过多的使用索引可能带来相反的问题，索引也是有缺点的： 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT,UPDATE和DELETE。因为更新表时，mysql不仅要保存数据，还要保存一下索引文件 建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在要给大表上建了多种组合索引，索引文件会膨胀很宽 索引只是提高效率的一个方式，如果mysql有大数据量的表，就要花时间研究建立最优的索引，或优化查询语句。 使用索引时，有一些技巧： 1.索引不会包含有NULL的列 ​ 只要列中包含有NULL值，都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此符合索引就是无效的。 2.使用短索引 ​ 对串列进行索引，如果可以就应该指定一个前缀长度。例如，如果有一个char（255）的列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。 3.索引列排序 ​ mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作，尽量不要包含多个列的排序，如果需要最好给这些列建复合索引。 4.like语句操作 一般情况下不鼓励使用like操作，如果非使用不可，注意正确的使用方式。like ‘%aaa%’不会使用索引，而like ‘aaa%’可以使用索引。 5.不要在列上进行运算 6.不使用NOT IN 、<>、！=操作，但,>=,BETWEEN,IN是可以用到索引的 7.索引要建立在经常进行select操作的字段上。 ​ 这是因为，如果这些列很少用到，那么有无索引并不能明显改变查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。 8.索引要建立在值比较唯一的字段上。 9.对于那些定义为text、image和bit数据类型的列不应该增加索引。因为这些列的数据量要么相当大，要么取值很少。 10.在where和join中出现的列需要建立索引。 11.where的查询条件里有不等号(where column != …),mysql将无法使用索引。 12.如果where字句的查询条件里使用了函数(如：where DAY(column)=…),mysql将无法使用索引。 13.在join操作中(需要从多个数据表提取数据时)，mysql只有在主键和外键的数据类型相同时才能使用索引，否则及时建立了索引也不会使用。 参考 【mysql 索引】mysql 添加索引 mysql索引使用技巧及注意事项 Update time： 2020-09-20 "},"MySQL/MySQL基础/不存在则插入，存在则更新或忽略.html":{"url":"MySQL/MySQL基础/不存在则插入，存在则更新或忽略.html","title":"不存在则插入，存在则更新或忽略","keywords":"","body":"不存在则插入，存在则更新或忽略 在插入数据时，可能需要忽略或替换掉重复的数据（依据某个字段），这时可以在应用层处理，也可以使用复杂的 SQL 语句来处理（如果仅仅知道一些简单的 SQL 语法的话），当然也可以使用一些简单的 SQL 语法，不过它并不是通用所有的数据库类型。 以下所有实例仅针对MySQL而言，并不能随意用于其它数据库 实例 表名称：student 表字段： Column Name Primary Key Auto Increment Unique id true true name true age 初始表数据： id name age 1 Jack 18 注：以下所有的示例都需要被插入的数据中需要存在UNIQUE索引或PRIMARY KEY字段，同时这里引入表的主键id，并设置成自动递增，后面可以看到它的变化 1. 不存在则插入，存在则更新 1.1 on duplicate key update 如果插入的数据会导致UNIQUE 索引或PRIMARY KEY发生冲突/重复，则执行UPDATE语句，例： INSERT INTO `student`(`name`, `age`) VALUES('Jack', 19) ON DUPLICATE KEY UPDATE `age`=19; -- If will happen conflict, the update statement is executed -- 2 row(s) affected12345 这里受影响的行数是2，因为数据库中存在name='Jack'的数据，如果不存在此条数据，则受影响的行数为1 最新的表数据如下： id name age 1 Jack 19 1.2 replace into 如果插入的数据会导致UNIQUE 索引或PRIMARY KEY发生冲突/重复，则先删除旧数据再插入最新的数据，例： REPLACE INTO `student`(`name`, `age`) VALUES('Jack', 18); -- 2 row(s) affected123 这里受影响的行数是2，因为数据库中存在name='Jack'的数据，并且id的值会变成2，因为它是先删除旧数据，然后再插入数据，最新的表数据如下： id name age 2 Jack 19 2. 避免重复插入 关键字/句：insert ignore into，如果插入的数据会导致UNIQUE索引或PRIMARY KEY发生冲突/重复，则忽略此次操作/不插入数据，例： INSERT IGNORE INTO `student`(`name`, `age`) VALUES('Jack', 18); -- 0 row(s) affected123 这里已经存在name='Jack'的数据，所以会忽略掉新插入的数据，受影响行数为0，表数据不变。 以上。 参考 Mysql实现不存在则插入，存在则更新 Update time： 2020-09-20 "},"MySQL/语句/MySQL 查询执行顺序.html":{"url":"MySQL/语句/MySQL 查询执行顺序.html","title":"MySQL 查询执行顺序","keywords":"","body":"MySQL 查询执行顺序 SQL 查询执行顺序 示例 SELECT DISTINCT t1.column1 AS alias1, t2.col2, aggregate_function(column3) FROM table1 t1 JOIN table2 t1 ON t1.column1 = t2.column1 WHERE conditions GROUP BY t1.column1, t2.col2 HAVING group_condition ORDER BY t1.column1 ASC, t2.col2 DESC OFFSET m ROWS FETCH NEXT num_rows ROWS ONLY; 以上就是 SQL 语法中常见的各个子句（当然不是全部子句）的书写顺序，但是它们的逻辑执行顺序却与此不同： 首先，FROM和JOIN是SQL执行的第一步，它们从逻辑上决定了接下来要操作的数据集； 其次，执行WHERE子句，对上一步的数据集进行过滤，保留满足条件的行；需要注意的是，此时还没有执行SELECT子句，WHERE条件中不能引用SELECT列表中的列别名（alias1）或者聚合函数 接下来，基于GROUP BY子句指定的表达式进行分组，分组条件有多少不同的取值，操作后的结果就有多少行； 然后，基于分组结果执行聚合函数 aggregate_function，对于每个分组取值，生成一个函数结果；如果没有分组子句，基于所有结果执行一次聚合操作； 如果查询中使用了GROUP BY，可以使用 HAVING 针对分组后的结果进一步进行过滤，通常是利用聚合函数的值进行过滤，如果是其他过滤条件，可以在WHERE子句中提前指定，避免无谓的操作； 接下来，SELECT子句可以选择要显示的列。如果存在GROUP BY子句，SELECT列表只能引用分组所使用的列，或者聚合函数；如果不存在GROUP BY子句，可以引用FROM和JOIN指定的表中的任何列； 如果在SELECT之后指定了DISTINCT关键字，需要针对上一步的结果集进行去重操作，过滤掉所有重复的值； 应用ORDER BY子句对上一步的结果进行最终的排序操作。如果存在GROUP BY子句或者DISTINCT关键字，只能使用SELECT列表中出现的字段进行排序；如果不存在GROUP BY子句和DISTINCT，可以使用FROM和JOIN指定的表中的任何列； 最后，OFFSET和FETCH（或者LIMIT、TOP）限定了返回的行。 参考： https://www.cnblogs.com/xiaohuochai/p/6081482.html Update time： 2020-08-19 "},"MySQL/语句/":{"url":"MySQL/语句/","title":"语句","keywords":"","body":"MySQL Update time： 2020-08-18 "},"MySQL/语句/INSERT语句.html":{"url":"MySQL/语句/INSERT语句.html","title":"INSERT语句","keywords":"","body":"INSERT语句 INSERT：插入数据（添加数据） 数据库与表创建成功以后，需要向数据库的表中插入数据。在 MySQL 中可以使用 INSERT 语句向数据库已有的表中插入一行或者多行元组数据。 基本语法 INSERT 语句有两种语法形式，分别是 INSERT…VALUES 语句和 INSERT…SET 语句。 INSERT…VALUES语句 INSERT VALUES 的语法格式为： INSERT INTO [ [ , … ] ] VALUES (值1) [… , (值n) ]; 语法说明如下。 ：指定被操作的表名。 ：指定需要插入数据的列名。若向表中的所有列插入数据，则全部的列名均可以省略，直接采用 INSERTVALUES(…) 即可。 VALUES 或 VALUE 子句：该子句包含要插入的数据清单。数据清单中数据的顺序要和列的顺序相对应。 INSERT…SET语句 语法格式为： INSERT INTO SET = , = , … 此语句用于直接给表中的某些列指定对应的列值，即要插入的数据的列名在 SET 子句中指定，col_name 为指定的列名，等号后面为指定的数据，而对于未指定的列，列值会指定为该列的默认值。 由 INSERT 语句的两种形式可以看出： 使用 INSERT…VALUES 语句可以向表中插入一行数据，也可以插入多行数据； 使用 INSERT…SET 语句可以指定插入行中每列的值，也可以指定部分列的值； INSERT…SELECT语句向表中插入其他表的数据。 采用INSERT…SET语句可以向表中插入部分列的值，这种方式更为灵活； INSERT…VALUES 语句可以一次插入多条数据。 在 MySQL 中，用单条 INSERT 语句处理多个插入要比使用多条 INSERT 语句更快。 当使用单条 INSERT 语句插入多行数据的时候，只需要将每行数据用圆括号括起来即可。 向表中的全部字段添加值 在 test_db 数据库中创建一个课程信息表 tb_courses，包含课程编号 course_id、课程名称 course_name、课程学分 course_grade 和课程备注 course_info，输入的 SQL 语句和执行结果如下所示。 mysql> CREATE TABLE tb_courses -> ( -> course_id INT NOT NULL AUTO_INCREMENT, -> course_name CHAR(40) NOT NULL, -> course_grade FLOAT NOT NULL, -> course_info CHAR(100) NULL, -> PRIMARY KEY(course_id) -> ); Query OK, 0 rows affected (0.00 sec) 向表中所有字段插入值的方法有两种：一种是指定所有字段名；另一种是完全不指定字段名。 【实例 1】在 tb_courses 表中插入一条新记录，course_id 值为 1，course_name 值为“Network”，course_grade 值为 3，info 值为“Computer Network”。 在执行插入操作之前，查看 tb_courses 表的SQL语句和执行结果如下所示。 mysql> SELECT * FROM tb_courses; Empty set (0.00 sec) 查询结果显示当前表内容为空，没有数据，接下来执行插入数据的操作，输入的 SQL 语句和执行过程如下所示。 mysql> INSERT INTO tb_courses -> (course_id,course_name,course_grade,course_info) -> VALUES(1,'Network',3,'Computer Network'); Query OK, 1 rows affected (0.08 sec) mysql> SELECT * FROM tb_courses; +-----------+-------------+--------------+------------------+ | course_id | course_name | course_grade | course_info | +-----------+-------------+--------------+------------------+ | 1 | Network | 3 | Computer Network | +-----------+-------------+--------------+------------------+ 1 row in set (0.00 sec) 可以看到插入记录成功。在插入数据时，指定了 tb_courses 表的所有字段，因此将为每一个字段插入新的值。 INSERT 语句后面的列名称顺序可以不是 tb_courses 表定义时的顺序，即插入数据时，不需要按照表定义的顺序插入，只要保证值的顺序与列字段的顺序相同就可以。 【实例 2】在 tb_courses 表中插入一条新记录，course_id 值为 2，course_name 值为“Database”，course_grade 值为 3，info值为“MySQL”。输入的 SQL 语句和执行结果如下所示。 mysql> INSERT INTO tb_courses -> (course_name,course_info,course_id,course_grade) -> VALUES('Database','MySQL',2,3); Query OK, 1 rows affected (0.08 sec) mysql> SELECT * FROM tb_courses; +-----------+-------------+--------------+------------------+ | course_id | course_name | course_grade | course_info | +-----------+-------------+--------------+------------------+ | 1 | Network | 3 | Computer Network | | 2 | Database | 3 | MySQL | +-----------+-------------+--------------+------------------+ 2 rows in set (0.00 sec) 使用 INSERT 插入数据时，允许列名称列表 column_list 为空，此时值列表中需要为表的每一个字段指定值，并且值的顺序必须和数据表中字段定义时的顺序相同。 【实例 3】在 tb_courses 表中插入一条新记录，course_id 值为 3，course_name 值为“Java”，course_grade 值为 4，info 值为“Jave EE”。输入的 SQL 语句和执行结果如下所示。 mysql> INSERT INTO tb_courses -> VLAUES(3,'Java',4,'Java EE'); Query OK, 1 rows affected (0.08 sec) mysql> SELECT * FROM tb_courses; +-----------+-------------+--------------+------------------+ | course_id | course_name | course_grade | course_info | +-----------+-------------+--------------+------------------+ | 1 | Network | 3 | Computer Network | | 2 | Database | 3 | MySQL | | 3 | Java | 4 | Java EE | +-----------+-------------+--------------+------------------+ 3 rows in set (0.00 sec) INSERT 语句中没有指定插入列表，只有一个值列表。在这种情况下，值列表为每一个字段列指定插入的值，并且这些值的顺序必须和 tb_courses 表中字段定义的顺序相同。 注意：虽然使用 INSERT 插入数据时可以忽略插入数据的列名称，若值不包含列名称，则 VALUES 关键字后面的值不仅要求完整，而且顺序必须和表定义时列的顺序相同。如果表的结构被修改，对列进行增加、删除或者位置改变操作，这些操作将使得用这种方式插入数据时的顺序也同时改变。如果指定列名称，就不会受到表结构改变的影响。 向表中指定字段添加值 为表的指定字段插入数据，是在 INSERT 语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值。 【实例 4】在 tb_courses 表中插入一条新记录，course_name 值为“System”，course_grade 值为 3，course_info 值为“Operating System”，输入的 SQL 语句和执行结果如下所示。 mysql> INSERT INTO tb_courses -> (course_name,course_grade,course_info) -> VALUES('System',3,'Operation System'); Query OK, 1 rows affected (0.08 sec) mysql> SELECT * FROM tb_courses; +-----------+-------------+--------------+------------------+ | course_id | course_name | course_grade | course_info | +-----------+-------------+--------------+------------------+ | 1 | Network | 3 | Computer Network | | 2 | Database | 3 | MySQL | | 3 | Java | 4 | Java EE | | 4 | System | 3 | Operating System | +-----------+-------------+--------------+------------------+ 4 rows in set (0.00 sec) 可以看到插入记录成功。如查询结果显示，这里的 course_id 字段自动添加了一个整数值 4。这时的 course_id 字段为表的主键，不能为空，系统自动为该字段插入自增的序列值。在插入记录时，如果某些字段没有指定插入值，MySQL 将插入该字段定义时的默认值。 INSERT INTO…FROM 语句复制表数据 INSERT INTO…SELECT…FROM 语句用于快速地从一个或多个表中取出数据，并将这些数据作为行数据插入另一个表中。 SELECT 子句返回的是一个查询到的结果集，INSERT 语句将这个结果集插入指定表中，结果集中的每行数据的字段数、字段的数据类型都必须与被操作的表完全一致。 在数据库 test_db 中创建一个与 tb_courses 表结构相同的数据表 tb_courses_new，创建表的 SQL 语句和执行过程如下所示。 mysql> CREATE TABLE tb_courses_new -> ( -> course_id INT NOT NULL AUTO_INCREMENT, -> course_name CHAR(40) NOT NULL, -> course_grade FLOAT NOT NULL, -> course_info CHAR(100) NULL, -> PRIMARY KEY(course_id) -> ); Query OK, 0 rows affected (0.00 sec) mysql> SELECT * FROM tb_courses_new; Empty set (0.00 sec) 【实例 5】从 tb_courses 表中查询所有的记录，并将其插入 tb_courses_new 表中。输入的 SQL 语句和执行结果如下所示。 mysql> INSERT INTO tb_courses_new -> (course_id,course_name,course_grade,course_info) -> SELECT course_id,course_name,course_grade,course_info -> FROM tb_courses; Query OK, 4 rows affected (0.17 sec) Records: 4 Duplicates: 0 Warnings: 0 mysql> SELECT * FROM tb_courses_new; +-----------+-------------+--------------+------------------+ | course_id | course_name | course_grade | course_info | +-----------+-------------+--------------+------------------+ | 1 | Network | 3 | Computer Network | | 2 | Database | 3 | MySQL | | 3 | Java | 4 | Java EE | | 4 | System | 3 | Operating System | +-----------+-------------+--------------+------------------+ 4 rows in set (0.00 sec) Update time： 2020-08-18 "},"MySQL/语句/UPDATE语句.html":{"url":"MySQL/语句/UPDATE语句.html","title":"UPDATE语句","keywords":"","body":"UPDATE语句 可以使用 UPDATE 语句来修改、更新一个或多个表的数据。 UPDATE 语句的基本语法 使用 UPDATE 语句修改单个表，语法格式为： UPDATE SET 字段1=值1 [,字段2=值2… ] [WHERE 子句 ] [ORDER BY 子句] [LIMIT 子句] 语法说明如下： ：用于指定要更新的表名称。 SET 子句：用于指定表中要修改的列名及其列值。其中，每个指定的列值可以是表达式，也可以是该列对应的默认值。如果指定的是默认值，可用关键字 DEFAULT 表示列值。 WHERE 子句：可选项。用于限定表中要修改的行。若不指定，则修改表中所有的行。 ORDER BY 子句：可选项。用于限定表中的行被修改的次序。 LIMIT 子句：可选项。用于限定被修改的行数。 注意：修改一行数据的多个列值时，SET 子句的每个值用逗号分开即可。 修改表中的数据 【实例 1】在 tb_courses_new 表中，更新所有行的 course_grade 字段值为 4，输入的 SQL 语句和执行结果如下所示。 mysql> UPDATE tb_courses_new -> SET course_grade=4; Query OK, 3 rows affected (0.11 sec) Rows matched: 4 Changed: 3 Warnings: 0 mysql> SELECT * FROM tb_courses_new; +-----------+-------------+--------------+------------------+ | course_id | course_name | course_grade | course_info | +-----------+-------------+--------------+------------------+ | 1 | Network | 4 | Computer Network | | 2 | Database | 4 | MySQL | | 3 | Java | 4 | Java EE | | 4 | System | 4 | Operating System | +-----------+-------------+--------------+------------------+ 4 rows in set (0.00 sec) 根据条件修改表中的数据 【实例 2】在 tb_courses 表中，更新 course_id 值为 2 的记录，将 course_grade 字段值改为 3.5，将 course_name 字段值改为“DB”，输入的 SQL 语句和执行结果如下所示。 mysql> UPDATE tb_courses_new -> SET course_name='DB',course_grade=3.5 -> WHERE course_id=2; Query OK, 1 row affected (0.13 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql> SELECT * FROM tb_courses_new; +-----------+-------------+--------------+------------------+ | course_id | course_name | course_grade | course_info | +-----------+-------------+--------------+------------------+ | 1 | Network | 4 | Computer Network | | 2 | DB | 3.5 | MySQL | | 3 | Java | 4 | Java EE | | 4 | System | 4 | Operating System | +-----------+-------------+--------------+------------------+ 4 rows in set (0.00 sec) 注意：保证 UPDATE 以 WHERE 子句结束，通过 WHERE 子句指定被更新的记录所需要满足的条件，如果忽略 WHERE 子句，MySQL 将更新表中所有的行。 案例 627. 交换工资 [简单] 给定一个 salary 表，如下所示，有 m = 男性 和 f = 女性 的值。交换所有的 f 和 m 值（例如，将所有 f 值更改为 m，反之亦然）。要求只使用一个更新（Update）语句，并且没有中间的临时表。 注意，您必只能写一个 Update 语句，请不要编写任何 Select 语句。 例如： id name sex salary 1 A m 2500 2 B f 1500 3 C m 5500 4 D f 500 运行你所编写的更新语句之后，将会得到以下表: id name sex salary 1 A f 2500 2 B m 1500 3 C f 5500 4 D m 500 解题 方法一： update salary set sex=if(sex='f','m','f'); 方法二 ：使用 case when...end UPDATE salary SET sex = CASE sex WHEN 'm' THEN 'f' ELSE 'm' END; ` Update time： 2020-08-18 "},"MySQL/语句/SELECT语句.html":{"url":"MySQL/语句/SELECT语句.html","title":"SELECT语句","keywords":"","body":"SELECT语句 SELECT：数据表查询语句 SELECT EXPR,...FROM tbl_name SELECT select_expr [,select_expr...] [ FROM tbl_references [WHERE where_condition] [GROUP BY {col_name | position} [ASC | DESC],...] [HAVING where_condition] [ORDER BY {col_name | expo | position} [ASC | DESC],...] [LIMIT {[offset,] row_count | row_count OFFSET offset}] ] 其中，各条子句的含义如下： {*|}包含星号通配符的字段列表，表示所要查询字段的名称。 ，…，表 1 和表 2 表示查询数据的来源，可以是单个或多个。 WHERE 是可选项，如果选择该项，将限定查询数据必须满足该查询条件。 GROUP BY，该子句告诉 MySQL 如何显示查询出来的数据，并按照指定的字段分组。 [ORDER BY]，该子句告诉 MySQL 按什么样的顺序显示查询出来的数据，可以进行的排序有升序（ASC）和降序（DESC），默认情况下是升序。 [LIMIT[，]]，该子句告诉 MySQL 每次显示查询出来的数据条数。 查询表达式的每个表达式表示想要查找的一列，必须有至少一个。多个列之间以英文逗号分开， 查询 id, username 两列。 select id, username from users; 在使用多表连接时，可能会出现不同的表中存在名称相同的字段，如果直接写字段，分不清到底是哪张数据表的字段。在字段名前加上数据表可以分辨出隶属于哪张数据表。 select users,id, users, username from users; 星号*号表示所有的列。tbl_name.* 可以表示命名表的所有列 . select * from users; 查询表达式可以使用 [AS] alias_name 为其赋予别名，别名可用于 GROUP BY, ORDER BY, HAVING 字句 . select id AS userId, username AS uname from users; Update time： 2020-08-18 "},"MySQL/语句/DISTINCT子句.html":{"url":"MySQL/语句/DISTINCT子句.html","title":"DISTINCT子句","keywords":"","body":"DISTINCT子句 DISTINCT 去重 使用DISTINCT过滤重复数据 DISTINCT 关键字的主要作用就是对数据表中一个或多个字段重复的数据进行过滤，只返回其中的一条数据给用户。 SELECT DISTINCT FROM ; 其中，“字段名”为需要消除重复记录的字段名称，多个字段时用逗号隔开。 使用 DISTINCT 关键字时需要注意以下几点： DISTINCT 关键字只能在 SELECT 语句中使用。 在对一个或多个字段去重时，DISTINCT 关键字必须在所有字段的最前面。 如果 DISTINCT 关键字后有多个字段，则会对多个字段进行组合去重，也就是说，只有多个字段组合起来完全是一样的情况下才会被去重。 在 SQL 中，提供了DISTINCT关键字，用于删除查询结果中的重复值。例如： SELECT DISTINCT first_name FROM employees; DISTINCT位于SELECT之后，可以基于多个列值进行查重操作，通用语法如下： SELECT DISTINCT column1, column2, ... FROM table; 为了消除重复值，数据库系统需要对结果进行排序，然后扫描重复值；因此，大量数据的重复值处理会降低查询的速度。 除了DISTINCT之外，另一个关键字是ALL，它不会排除重复的结果，而是显示所有数据： SELECT [ALL | DISTINCT] column1, column2, ... FROM table; 如果不指定，默认值为ALL。 参考 SQL中distinct的用法 Update time： 2020-09-09 "},"MySQL/语句/LIMIT语句.html":{"url":"MySQL/语句/LIMIT语句.html","title":"LIMIT语句","keywords":"","body":"LIMIT语句 LIMIT: 限制查询结果的条数 限制查询结果的条数 SQL 标准中对查询结果进行限制的OFFSET子句和FETCH子句 [LIMIT {[offset,] row_count | row_count OFFSET offset}] 指定初始位置 LIMIT 初始位置，记录数 其中，“初始位置”表示从哪条记录开始显示；“记录数”表示显示记录的条数。第一条记录的位置是 0，第二条记录的位置是 1。后面的记录依次类推。 不指定初始位置 LIMIT 记录数 其中，“记录数”表示显示记录的条数。如果“记录数”的值小于查询结果的总数，则会从第一条记录开始，显示指定条数的记录。如果“记录数”的值大于查询结果的总数，则会直接显示查询出来的所有记录。 限制查询结果 (LIMIT) 默认情况下，返回所有查找到的结果 如果 LIMIT 后面只有一个数字，表示从第一条开始返回，并返回相应数字个数的记录 select * from usres limit 2; 从第一条开始，返回两条记录。 LIMIT 和 OFFSET组合使用 LIMIT 记录数 OFFSET 初始位置 参数和 LIMIT 语法中参数含义相同，“初始位置”指定从哪条记录开始显示；“记录数”表示显示记录的条数。 SELECT 语句默认从0开始编号，如果想从第三条开始返回，则需要 offset 参数和 row_count 参数一起使用 select * from usres limit 2,2; SELECT first_name, last_name, salary FROM employees ORDER BY salary DESC LIMIT 5, 10; -- return from 5th to 14th -- LIMIT 10 OFFSET 5; Top-N 查询 由于不同数据库的实现存在较大差异, 先以 Oracle 12c 语法为例 SELECT first_name, last_name, salary FROM employees ORDER BY salary DESC FETCH FIRST 10 ROWS ONLY; 以上查询返回薪水最高的前 10 位员工。首先，ORDER BY子句定义了按照薪水从高到低排序；然后FETCH子句指定了只返回前 10 条记录。 分页查询 考虑另一个场景，假如应用提供了分页显示的功能，每页显示 10 条记录，点击下一页时，需要显示第 11 到第 20 条记录。 SELECT first_name, last_name, salary FROM employees ORDER BY salary DESC OFFSET 10 ROWS FETCH FIRST 10 ROWS ONLY; SQL 标准中的完整定义： SELECT column1, column2, ... FROM table [WHERE conditions] [ORDER BY column1 ASC, column2 DESC, ...] [OFFSET m {ROW | ROWS}] [FETCH { FIRST | NEXT } [ num_rows | n PERCENT ] { ROW | ROWS } { ONLY | WITH TIES }]; 其中，OFFSET 表示偏移量，即从第 m+1 行开始返回；如果不指定，从第 1 行开始返回。 FETCH 用于指定返回多少行，FIRST 和NEXT 等价；num_rows 表示行数，n PERCENT 表示即按照百分比指定行数，ROW 和ROWS 等价；ONLY 和WITH TIES 的差别在于，如果最后存在更多排名相同的数据行，WITH TIES会返回更多的数据。 以下查询按照百分比返回前10%的数据： SELECT first_name, last_name, salary FROM employees ORDER BY salary DESC FETCH FIRST 10 PERCENT ROWS ONLY; Update time： 2020-08-18 "},"MySQL/语句/OFFSET FETCH语句.html":{"url":"MySQL/语句/OFFSET FETCH语句.html","title":"OFFSET FETCH语句","keywords":"","body":"OFFSET FETCH语句 语法 The following illustrates the syntax of the OFFSET and FETCH clauses: ORDER BY column_list [ASC |DESC] OFFSET offset_row_count {ROW | ROWS} FETCH {FIRST | NEXT} fetch_row_count {ROW | ROWS} ONLY In this syntax: The OFFSET clause specifies the number of rows to skip before starting to return rows from the query. The offset_row_count can be a constant, variable, or parameter that is greater or equal to zero. The FETCH clause specifies the number of rows to return after the OFFSET clause has been processed. The offset_row_count can a constant, variable or scalar that is greater or equal to one. The OFFSET clause is mandatory while the FETCH clause is optional. Also, the FIRST and NEXT are synonyms(同义词) respectively so you can use them interchangeably(可互换). Similarly, you can use the FIRST and NEXT interchangeably. The following illustrates the OFFSET and FETCH clauses: Note that you must use the OFFSET and FETCH clauses with the ORDER BY clause. Otherwise, you will get an error. We will use the products table from the sample database for the demonstration. The following query returns all products from the products table and sorts the products by their list prices and names: SELECT product_name, list_price FROM production.products ORDER BY list_price, product_name; To skip the first 10 products and return the rest, you use the OFFSET clause as shown in the following statement: SELECT product_name, list_price FROM production.products ORDER BY list_price, product_name OFFSET 10 ROWS; To skip the first 10 products and select the next 10 products, you use both OFFSET and FETCH clauses as follows: SELECT product_name, list_price FROM production.products ORDER BY list_price, product_name OFFSET 10 ROWS FETCH NEXT 10 ROWS ONLY; To get the top 10 most expensive products you use both OFFSET and FETCH clauses: SELECT product_name, list_price FROM production.products ORDER BY list_price DESC, product_name OFFSET 0 ROWS FETCH FIRST 10 ROWS ONLY; In this example, the ORDER BY clause sorts the products by their list prices in descending order. Then, the OFFSET clause skips zero row and the FETCH clause fetches the first 10 products from the list. 分页实现：Offset-Fetch Offset-Fetch子句要求结果集是有序的，因此，只能用于order by 子句中，语法如下： ORDER BY order_by_expression [ ASC | DESC ] [ ,...n ] [ ] ::= { OFFSET { integer_constant | offset_row_count_expression } ROWS [ FETCH NEXT {integer_constant | fetch_row_count_expression } ROWS ONLY ] } 关键字解析： Offset子句：用于指定跳过（Skip）的数据行； Fetch子句：该子句在Offset子句之后执行，表示在跳过（Sikp）指定数量的数据行之后，返回一定数据量的数据行； 执行顺序：Offset子句必须在Order By 子句之后执行，Fetch子句必须在Offset子句之后执行； 分页实现的思路： 在分页实现中，使用Order By子句，按照指定的columns对结果集进行排序； 使用Offset子句跳过前N页：Offset (@PageIndex-1)*@RowsPerPage rows； 使用Fetch子句呈现当前Page：Fetch next @RowsPerPage rows only； 使用order-offset-fetch分页 创建示例数据 use tempdb go create table dbo.dt_test ( id int, code int ) go insert into dbo.dt_test(id,code) values(1,1),(2,2),(3,1),(4,2),(5,1),(6,2) 使用Offset子句跳过指定数目的数据行 select * from dbo.dt_test order by id offset 2 rows 使用Offset-Fetch子句跳过指定数目的数据行之后，返回指定数目的数据行 select * from dbo.dt_test order by id offset 2 rows fetch next 2 rows only 修改成分页的通用格式 --分页的索引，页码从1开始 declare @PageIndex int --每页显示的行数 declare @Size int set @PageIndex=1 set @Size=100 select * from dbo.dt_test order by id offset (@PageIndex - 1) * @Size rows fetch next @Size rows only 排序（order by） order by子句的语法是：ORDER BY order_by_expression ，用于按照指定字段进行排序，通常有3种写法： select子句中列的name，或alias，排序子句（order by）的执行顺序在select子句之后，可以使用列的Alias进行排序； 表达式，按照表达式的计算结果进行排序； select子句中列的序号，从1开始，此处的数值是序号，不建议使用； 上述三种写法都会对查询结果集进行排序，返回的结果集是有序的，但是，如果这样写，在order by子句中使用一个常量： order by (select 1) 该子句中的 1 不是列的序号，而是常量，SQL Server按照结果集的原始顺序返回，order by子句不对结果集排序。 参考 SQL Server OFFSET FETCH 分页实现：Offset-Fetch Update time： 2020-08-19 "},"MySQL/语句/limit 与 limit，offset连用的区别.html":{"url":"MySQL/语句/limit 与 limit，offset连用的区别.html","title":"limit 与 limit，offset连用的区别","keywords":"","body":"limit 与 limit，offset连用的区别 select * from table limit 2,1; 含义是跳过2条取出1条数据，limit后面是从第2条开始读，读取1条信息，即读取第3条数据 select * from table limit 2 offset 1; 含义是从第1条（不包括）数据开始取出2条数据，limit后面跟的是2条数据，offset后面是从第1条开始读取，即读取第2,3条 使用查询语句的时候，经常要返回前几条或者中间某几行数据，这个时候怎么办呢？不用担心，已 经为我们提供了这样一个功能。 LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。 如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。 SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset 这是两个参数，第一个是偏移量，第二个是数目 select * from employee limit 3, 7; // 返回4-11行 select * from employee limit 3,1; // 返回第4行 一个参数 select * from employee limit 3; // 返回前3行 参考 sql 中 limit 与 limit，offset连用的区别 Update time： 2020-08-19 "},"MySQL/语句/ORDER BY语句.html":{"url":"MySQL/语句/ORDER BY语句.html","title":"ORDER BY语句","keywords":"","body":"ORDER BY语句 ORDER BY：对查询结果排序 ORDER BY 关键字主要用来将查询结果中的数据按照一定的顺序进行排序。其语法格式如下： ORDER BY [ASC|DESC] 语法说明如下。 字段名：表示需要排序的字段名称，多个字段时用逗号隔开。 ASC|DESC：ASC表示字段按升序排序；DESC表示字段按降序排序。其中ASC为默认值。 使用 ORDER BY 关键字应该注意以下几个方面： ORDER BY 关键字后可以跟子查询（关于子查询后面教程会详细讲解，这里了解即可）。 当排序的字段中存在空值时，ORDER BY 会将该空值作为最小值来对待。 ORDER BY 指定多个字段进行排序时，MySQL 会按照字段的顺序从左到右依次进行排序。 单字段排序 SELECT * FROM tb_students_info ORDER BY height 多字段排序 SELECT name,height FROM tb_students_info ORDER BY height,name; 注意：在对多个字段进行排序时，排序的第一个字段必须有相同的值，才会对第二个字段进行排序。如果第一个字段数据中所有的值都是唯一的，MySQL 将不再对第二个字段进行排序。 默认情况下，查询数据按字母升序进行排序（A～Z），但数据的排序并不仅限于此，还可以使用 ORDER BY 中的 DESC 对查询结果进行降序排序（Z～A）。 SELECT name,height FROM tb_student_info ORDER BY height DESC,name ASC; 按列的位置排序 SELECT name,height FROM tb_student_info ORDER BY 3 DESC,name ASC; 数字 3 表示按表的第三列的字段排序 注意： 不支持大小写的排序 在指定一条 order by 子句时，应该保证它是 select 语句中最后一条子句。 SQL 时间排序 sql 中的时间排序 例如 sql = \"select * from user where Putout=true order by time desc\" //按最新时间来排序 sql = \"select * from user where Putout=true order by time asc\" //按早时间来排序 可以把时间理解成 时间是有小到大增加的，当成普通的数字。 Update time： 2020-09-04 "},"MySQL/语句/WHERE语句.html":{"url":"MySQL/语句/WHERE语句.html","title":"WHERE语句","keywords":"","body":"WHERE语句 WHERE：条件查询数据 在 MySQL 中，如果需要有条件的从数据表中查询数据，可以使用 WHERE关键字来指定查询条件。 使用 WHERE 关键字的语法格式如下： 1 WHERE 查询条件 查询条件可以是： 带比较运算符和逻辑运算符的查询条件 带 BETWEEN AND关键字的查询条件 带IS NULL关键字的查询条件 带 IN关键字的查询条件 带 LIKE关键字的查询条件 单一条件的查询语句 单一条件指的是在 WHERE 关键字后只有一个查询条件。 在 tb_students_info 数据表中查询身高为 170cm 的学生姓名，SQL 语句和运行结果如下。 1 mysql> SELECT name,height FROM tb_students_info 2 -> WHERE height=170; 多条件的查询语句 在 WHERE 关键词后可以有多个查询条件，这样能够使查询结果更加精确。多个查询条件时用逻辑运算符 AND（&&）、OR（||）或 XOR 隔开。 AND：记录满足所有查询条件时，才会被查询出来。 OR：记录满足任意一个查询条件时，才会被查询出来。 XOR：记录满足其中一个条件，并且不满足另一个条件时，才会被查询出来。 在 tb_students_info 表中查询 age 大于 21，并且 height 大于等于 175 的学生信息，SQL 语句和运行结果如下。 1 mysql> SELECT name,age,height FROM tb_students_info -> WHERE age>21 AND height>=175; 注意事项： 同时使用 order by 和 where 子句时，应该让 order by 位于where 之后。 Update time： 2020-08-18 "},"MySQL/语句/GROUP BY语句.html":{"url":"MySQL/语句/GROUP BY语句.html","title":"GROUP BY语句","keywords":"","body":"GROUP BY语句 GROUP BY分组查询 在 MySQL 中，GROUP BY 关键字可以根据一个或多个字段对查询结果进行分组。 GROUP BY 其中，“字段名”表示需要分组的字段名称，多个字段时用逗号隔开。 GROUP BY单独使用 单独使用 GROUP BY 关键字时，查询结果会只显示每个分组的第一条记录。 mysql> SELECT `name`,`sex` FROM tb_students_info -> GROUP BY sex; +-------+------+ | name | sex | +-------+------+ | Henry | 女 | | Dany | 男 | +-------+------+ 2 rows in set (0.01 sec) GROUP BY 与 GROUP_CONCAT() GROUP BY 关键字可以和 GROUP_CONCAT()函数一起使用。GROUP_CONCAT()函数会把每个分组的字段值都显示出来。 mysql> SELECT `sex`, GROUP_CONCAT(name) FROM tb_students_info -> GROUP BY sex; +------+----------------------------+ | sex | GROUP_CONCAT(name) | +------+----------------------------+ | 女 | Henry,Jim,John,Thomas,Tom | | 男 | Dany,Green,Jane,Lily,Susan | +------+----------------------------+ 2 rows in set (0.00 sec 下面根据 tb_students_info 表中的 age 和 sex 字段进行分组查询。SQL 语句和运行结果如下： mysql> SELECT age,sex,GROUP_CONCAT(name) FROM tb_students_info -> GROUP BY age,sex; +------+------+--------------------+ | age | sex | GROUP_CONCAT(name) | +------+------+--------------------+ | 21 | 女 | John | | 22 | 女 | Thomas | | 22 | 男 | Jane,Lily | | 23 | 女 | Henry,Tom | | 23 | 男 | Green,Susan | | 24 | 女 | Jim | | 25 | 男 | Dany | +------+------+--------------------+ 7 rows in set (0.00 sec) 上面实例在分组过程中，先按照 age 字段进行分组，当 age 字段值相等时，再把 age 字段值相等的记录按照 sex 字段进行分组。 多个字段分组查询时，会先按照第一个字段进行分组。如果第一个字段中有相同的值，MySQL 才会按照第二个字段进行分组。如果第一个字段中的数据都是唯一的，那么 MySQL 将不再对第二个字段进行分组。 GROUP BY 与聚合函数 在数据统计时，GROUP BY 关键字经常和聚合函数一起使用。 聚合函数包括 COUNT()，SUM()，AVG()，MAX()和 MIN()。其中，COUNT()用来统计记录的条数；SUM()用来计算字段值的总和；AVG() 用来计算字段值的平均值；MAX() 用来查询字段的最大值；MIN() 用来查询字段的最小值。 下面根据 tb_students_info 表的 sex 字段进行分组查询，使用 COUNT()函数计算每一组的记录数。SQL 语句和运行结果如下： mysql> SELECT sex,COUNT(sex) FROM tb_students_info -> GROUP BY sex; +------+------------+ | sex | COUNT(sex) | +------+------------+ | 女 | 5 | | 男 | 5 | +------+------------+ 2 rows in set (0.00 sec) 如果 group by 中嵌套了分组，数据将在最后的分组上进行汇总 GROUP BY 与 WITH ROLLUP WITH POLLUP 关键字用来在所有记录的最后加上一条记录，这条记录是上面所有记录的总和，即统计记录数量。 下面根据 tb_students_info 表中的 sex 字段进行分组查询，并使用 WITH ROLLUP 显示记录的总和。 mysql> SELECT sex,GROUP_CONCAT(name) FROM tb_students_info ->GROUP BY sex WITH ROLLUP; +------+------------------------------------------------------+ | sex | GROUP_CONCAT(name) | +------+------------------------------------------------------+ | 女 | Henry,Jim,John,Thomas,Tom | | 男 | Dany,Green,Jane,Lily,Susan | | NULL | Henry,Jim,John,Thomas,Tom,Dany,Green,Jane,Lily,Susan | +------+------------------------------------------------------+ 3 rows in set (0.00 sec) 查询结果显示，GROUP_CONCAT(name) 显示了每个分组的 name 字段值。同时，最后一条记录的 GROUP_CONCAT(name) 字段的值刚好是上面分组 name 字段值的总和。 注意事项 如果 group by 中嵌套了分组，数据将在最后的分组上进行汇总 group by 子句必须在 where 子句之后，ordre by 子句之前。 如果分组中含有 null 值的行，则将 null 作为一个分组返回。如果列中有多个 null 值，它们将分为一组。 Update time： 2020-08-18 "},"MySQL/语句/HAVING语句.html":{"url":"MySQL/语句/HAVING语句.html","title":"HAVING语句","keywords":"","body":"HAVING语句 HAVING：过滤分组 在 MySQL 中，可以使用 HAVING 关键字对分组后的数据进行过滤。 使用 HAVING 关键字的语法格式如下： HAVING HAVING 关键字和 WHERE关键字都可以用来过滤数据，且 HAVING 支持 WHERE关键字中所有的操作符和语法。 但是 WHERE 和 HAVING关键字也存在以下几点差异： 一般情况下，WHERE 用于过滤数据行，而 HAVING 用于过滤分组。 WHERE 查询条件中不可以使用聚合函数，而 HAVING 查询条件中可以使用聚合函数。 WHERE 在数据分组前进行过滤，而 HAVING 在数据分组后进行过滤 。 WHERE 针对数据库文件进行过滤，而 HAVING 针对查询结果进行过滤。也就是说，WHERE 根据数据表中的字段直接进行过滤，而 HAVING 是根据前面已经查询出的字段进行过滤。 WHERE 查询条件中不可以使用字段别名，而 HAVING 查询条件中可以使用字段别名。 例 1 分别使用 HAVING 和 WHERE 关键字查询出 tb_students_info 表中身高大于 150 的学生姓名，性别和身高。SQL 语句和运行结果如下。 mysql> SELECT name,sex,height FROM tb_students_info -> HAVING height>150; +--------+------+--------+ | name | sex | height | +--------+------+--------+ | Dany | 男 | 160 | | Green | 男 | 158 | | Henry | 女 | 185 | | Jane | 男 | 162 | | Jim | 女 | 175 | | John | 女 | 172 | | Lily | 男 | 165 | | Susan | 男 | 170 | | Thomas | 女 | 178 | | Tom | 女 | 165 | +--------+------+--------+ 10 rows in set (0.00 sec) mysql> SELECT name,sex,height FROM tb_students_info -> WHERE height>150; +--------+------+--------+ | name | sex | height | +--------+------+--------+ | Dany | 男 | 160 | | Green | 男 | 158 | | Henry | 女 | 185 | | Jane | 男 | 162 | | Jim | 女 | 175 | | John | 女 | 172 | | Lily | 男 | 165 | | Susan | 男 | 170 | | Thomas | 女 | 178 | | Tom | 女 | 165 | +--------+------+--------+ 10 rows in set (0.00 sec) 上述实例中，因为在 SELECT 关键字后已经查询出了 height 字段，所以 HAVING 和 WHERE 都可以使用。但是如果 SELECT 关键字后没有查询出 height 字段，MySQL 就会报错。 例 2 使用 HAVING 和 WHERE 关键字分别查询出 tb_students_info 表中身高大于 150 的学生姓名和性别（与例 1 相比，这次没有查询 height 字段）。SQL 语句和运行结果如下。 mysql> SELECT name,sex FROM tb_students_info -> HAVING height>150; +--------+------+ | name | sex | +--------+------+ | Dany | 男 | | Green | 男 | | Henry | 女 | | Jane | 男 | | Jim | 女 | | John | 女 | | Lily | 男 | | Susan | 男 | | Thomas | 女 | | Tom | 女 | +--------+------+ 10 rows in set (0.00 sec) mysql> SELECT name,sex FROM tb_students_info HAVING height>150; ERROR 1054 (42S22): Unknown column 'height' in 'having clause' 由结果可以看出，如果 SELECT 关键字后没有查询出 HAVING 查询条件中使用的 height 字段，MySQL 会提示错误信息：“having子句”中的列“height”未知”。 例 3 根据 height 字段对 tb_students_info 表中的数据进行分组，并使用 HAVING 和 WHERE 关键字分别查询出分组后平均身高大于 170 的学生姓名、性别和身高。SQL 语句和运行结果如下。 mysql> SELECT GROUP_CONCAT(name),sex,height FROM tb_students_info -> GROUP BY height -> HAVING AVG(height)>170; +--------------------+------+--------+ | GROUP_CONCAT(name) | sex | height | +--------------------+------+--------+ | John | 女 | 172 | | Jim | 女 | 175 | | Thomas | 女 | 178 | | Henry | 女 | 185 | +--------------------+------+--------+ 4 rows in set (0.00 sec) mysql> SELECT GROUP_CONCAT(name),sex,height FROM tb_students_info WHERE AVG(height)>170 GROUP BY height; ERROR 1111 (HY000): Invalid use of group function 由结果可以看出，如果在 WHERE 查询条件中使用聚合函数，MySQL 会提示错误信息：无效使用组函数。 Update time： 2020-08-18 "},"MySQL/语句/BETWEEN AND语句.html":{"url":"MySQL/语句/BETWEEN AND语句.html","title":"BETWEEN AND语句","keywords":"","body":"BETWEEN AND语句 BETWEEN AND：范围查询 MySQL 提供了BETWEEN AND 关键字，用来判断字段的数值是否在指定范围内。 BETWEEN AND 需要两个参数，即范围的起始值和终止值。如果字段值在指定的范围内，则这些记录被返回。如果不在指定范围内，则不会被返回。 使用 BETWEEN AND 的基本语法格式如下： [NOT] BETWEEN 取值1 AND 取值2 其中： NOT：可选参数，表示指定范围之外的值。如果字段值不满足指定范围内的值，则这些记录被返回。 取值1：表示范围的起始值。 取值2：表示范围的终止值。 BETWEEN AND 和 NOT BETWEEN AND关键字在查询指定范围内的记录时很有用。例如，查询学生的年龄段、出生日期，员工的工资水平等。 在表 tb_students_info 中查询年龄在 20 到 23 之间的学生姓名和年龄，SQL 语句和运行结果如下。 mysql> SELECT name,age FROM tb_students_info -> WHERE age BETWEEN 20 AND 23; 查询结果中包含学生年龄为 20 和 23 的记录，这就说明，在 MySQL 中，BETWEEN AND 能匹配指定范围内的所有值，包括起始值和终止值。 Update time： 2020-08-18 "},"MySQL/语句/LIKE语句.html":{"url":"MySQL/语句/LIKE语句.html","title":"LIKE语句","keywords":"","body":"LIKE语句 LIKE：模糊查询 在 MySQL 中，LIKE 关键字主要用于搜索匹配字段中的指定内容。其语法格式如下： [NOT] LIKE '字符串' 其中： NOT ：可选参数，字段中的内容与指定的字符串不匹配时满足条件。 字符串：指定用来匹配的字符串。“字符串”可以是一个很完整的字符串，也可以包含通配符。 LIKE 关键字支持百分号“%”和下划线“_”通配符。 带有%通配符的查询 “%”是 MySQL 中最常用的通配符，它能代表任何长度的字符串，字符串的长度可以为 0。例如，a%b表示以字母 a 开头，以字母 b 结尾的任意长度的字符串。该字符串可以代表 ab、acb、accb、accrb 等字符串。 在 tb_students_info 表中，查找所有以字母“T”开头的学生姓名，SQL 语句和运行结果如下。 mysql> SELECT name FROM tb_students_info -> WHERE name LIKE 'T%'; 带有“_”通配符的查询 “_”只能代表单个字符，字符的长度不能为 0。例如，a_b可以代表 acb、adb、aub 等字符串。 在 tb_students_info 表中，查找所有以字母“y”结尾，且“y”前面只有 4 个字母的学生姓名，SQL 语句和运行结果如下。 mysql> SELECT name FROM tb_students_info -> WHERE name LIKE '____y'; 方括号[] 通配符 方括号 [] 通配符用来指定一个字符集，他必须匹配指定位置(通配符的位置) 的一个字符 例如，找出所有名字以 J 或 M 起头的联系人， select * from customers where cust_contact like '[JM]%' [JM] 匹配方括号中任意一个字符 此通配符可以用前缀字符 ^(脱字号) 来否定 例如，查询匹配以J 和M 之外的任意字符起头的联系人。 select * from customers where cust_contact like '[^JM]%' LIKE 区分大小写 默认情况下，LIKE 关键字匹配字符的时候是不区分大小写的。如果需要区分大小写，可以加入 BINARY 关键字。 在 tb_students_info 表中，查找所有以字母“t”开头的学生姓名，区分大小写和不区分大小写的 SQL 语句和运行结果如下。 mysql> SELECT name FROM tb_students_info WHERE name LIKE 't%'; +--------+ | name | +--------+ | Thomas | | Tom | +--------+ 2 rows in set (0.00 sec) mysql> SELECT name FROM tb_students_info WHERE name LIKE BINARY 't%'; Empty set (0.01 sec) 使用通配符的注意事项和技巧 下面是使用通配符的一些注意事项： 注意大小写。MySQL 默认是不区分大小写的。如果区分大小写，像“Tom”这样的数据就不能被“t%”所匹配到。 注意尾部空格，尾部空格会干扰通配符的匹配。例如，“T% ”就不能匹配到“Tom”。 注意 NULL。“%”通配符可以到匹配任意字符，但是不能匹配 NULL。也就是说 “%”匹配不到 tb_students_info 数据表中值为 NULL 的记录。 下面是一些使用通配符要记住的技巧。 不要过度使用通配符，如果其它操作符能达到相同的目的，应该使用其它操作符。因为 MySQL 对通配符的处理一般会比其他操作符花费更长的时间。 在确定使用通配符后，除非绝对有必要，否则不要把它们用在字符串的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。 Update time： 2020-08-18 "},"MySQL/语句/IS NULL语句.html":{"url":"MySQL/语句/IS NULL语句.html","title":"IS NULL语句","keywords":"","body":"IS NULL语句 NULL：空值查询 MySQL 提供了 IS NULL关键字，用来判断字段的值是否为空值（NULL）。空值不同于 0，也不同于空字符串。 如果字段的值是空值，则满足查询条件，该记录将被查询出来。如果字段的值不是空值，则不满足查询条件。 使用 IS NULL 的基本语法格式如下： IS [NOT] NULL 其中，“NOT”是可选参数，表示字段值不是空值时满足条件。 下面使用IS NULL关键字来查询 tb_students_info 表中 login_date 字段是 NULL 的记录。 mysql> SELECT `name`,`login_date` FROM tb_students_info -> WHERE login_date IS NULL; +--------+------------+ | NAME | login_date | +--------+------------+ | Dany | NULL | | Green | NULL | | Henry | NULL | | Jane | NULL | | Thomas | NULL | | Tom | NULL | +--------+------------+ 6 rows in set (0.01 sec) 注意：IS NULL 是一个整体，不能将 IS 换成“=”。如果将 IS 换成“=”将不能查询出任何结果，数据库系统会出现“Empty set(0.00 sec)”这样的提示。同理，IS NOT NULL 中的 IS NOT 不能换成“!=”或“<>”。 IS NOT NULL 表示查询字段值不为空的记录。 下面使用 IS NOT NULL 关键字来查询 tb_students_info 表中 login_date 字段不为空的记录。 mysql> SELECT `name`,login_date FROM tb_students_info -> WHERE login_date IS NOT NULL; Update time： 2020-08-18 "},"MySQL/语句/CROSS JOIN语句.html":{"url":"MySQL/语句/CROSS JOIN语句.html","title":"CROSS JOIN语句","keywords":"","body":"CROSS JOIN语句 CROSS JOIN：交叉连接 在关系型数据库中，表与表之间是有联系的，所以在实际应用中，经常使用多表查询。多表查询就是同时查询两个或两个以上的表。 交叉连接（CROSS JOIN）一般用来返回连接表的笛卡尔积。 交叉连接的语法格式如下： SELECT FROM CROSS JOIN [WHERE子句] -- 或 SELECT FROM , [WHERE子句] 语法说明如下： 字段名：需要查询的字段名称。 ：需要交叉连接的表名。 WHERE 子句：用来设置交叉连接的查询条件。 当连接的表之间没有关系时，我们会省略掉 WHERE 子句，这时返回结果就是两个表的笛卡尔积，返回结果数量就是两个表的数据行相乘。需要注意的是，如果每个表有 1000 行，那么返回结果的数量就有 1000×1000 = 1000000 行，数据量是非常巨大的。 交叉连接可以查询两个或两个以上的表，为了让读者更好的理解，下面先讲解两个表的交叉连接查询。 例 1 查询学生信息表和科目信息表，并得到一个笛卡尔积。 为了方便观察学生信息表和科目表交叉连接后的运行结果，我们先分别查询出这两个表的数据，再进行交叉连接查询。 1）查询 tb_students_info 表中的数据，SQL 语句和运行结果如下： mysql> SELECT * FROM tb_students_info; +----+--------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+--------+------+------+--------+-----------+ | 1 | Dany | 25 | 男 | 160 | 1 | | 2 | Green | 23 | 男 | 158 | 2 | | 3 | Henry | 23 | 女 | 185 | 1 | | 4 | Jane | 22 | 男 | 162 | 3 | | 5 | Jim | 24 | 女 | 175 | 2 | | 6 | John | 21 | 女 | 172 | 4 | | 7 | Lily | 22 | 男 | 165 | 4 | | 8 | Susan | 23 | 男 | 170 | 5 | | 9 | Thomas | 22 | 女 | 178 | 5 | | 10 | Tom | 23 | 女 | 165 | 5 | +----+--------+------+------+--------+-----------+ 10 rows in set (0.00 sec) 2）查询 tb_course 表中的数据，SQL 语句和运行结果如下： mysql> SELECT * FROM tb_course; +----+-------------+ | id | course_name | +----+-------------+ | 1 | Java | | 2 | MySQL | | 3 | Python | | 4 | Go | | 5 | C++ | +----+-------------+ 5 rows in set (0.00 sec) 3）使用 CROSS JOIN 查询出两张表中的笛卡尔积，SQL 语句和运行结果如下： mysql> SELECT * FROM tb_course CROSS JOIN tb_students_info; +----+-------------+----+--------+------+------+--------+-----------+ | id | course_name | id | name | age | sex | height | course_id | +----+-------------+----+--------+------+------+--------+-----------+ | 1 | Java | 1 | Dany | 25 | 男 | 160 | 1 | | 2 | MySQL | 1 | Dany | 25 | 男 | 160 | 1 | | 3 | Python | 1 | Dany | 25 | 男 | 160 | 1 | | 4 | Go | 1 | Dany | 25 | 男 | 160 | 1 | | 5 | C++ | 1 | Dany | 25 | 男 | 160 | 1 | | 1 | Java | 2 | Green | 23 | 男 | 158 | 2 | | 2 | MySQL | 2 | Green | 23 | 男 | 158 | 2 | | 3 | Python | 2 | Green | 23 | 男 | 158 | 2 | | 4 | Go | 2 | Green | 23 | 男 | 158 | 2 | | 5 | C++ | 2 | Green | 23 | 男 | 158 | 2 | | 1 | Java | 3 | Henry | 23 | 女 | 185 | 1 | | 2 | MySQL | 3 | Henry | 23 | 女 | 185 | 1 | | 3 | Python | 3 | Henry | 23 | 女 | 185 | 1 | | 4 | Go | 3 | Henry | 23 | 女 | 185 | 1 | | 5 | C++ | 3 | Henry | 23 | 女 | 185 | 1 | | 1 | Java | 4 | Jane | 22 | 男 | 162 | 3 | | 2 | MySQL | 4 | Jane | 22 | 男 | 162 | 3 | | 3 | Python | 4 | Jane | 22 | 男 | 162 | 3 | | 4 | Go | 4 | Jane | 22 | 男 | 162 | 3 | | 5 | C++ | 4 | Jane | 22 | 男 | 162 | 3 | | 1 | Java | 5 | Jim | 24 | 女 | 175 | 2 | | 2 | MySQL | 5 | Jim | 24 | 女 | 175 | 2 | | 3 | Python | 5 | Jim | 24 | 女 | 175 | 2 | | 4 | Go | 5 | Jim | 24 | 女 | 175 | 2 | | 5 | C++ | 5 | Jim | 24 | 女 | 175 | 2 | | 1 | Java | 6 | John | 21 | 女 | 172 | 4 | | 2 | MySQL | 6 | John | 21 | 女 | 172 | 4 | | 3 | Python | 6 | John | 21 | 女 | 172 | 4 | | 4 | Go | 6 | John | 21 | 女 | 172 | 4 | | 5 | C++ | 6 | John | 21 | 女 | 172 | 4 | | 1 | Java | 7 | Lily | 22 | 男 | 165 | 4 | | 2 | MySQL | 7 | Lily | 22 | 男 | 165 | 4 | | 3 | Python | 7 | Lily | 22 | 男 | 165 | 4 | | 4 | Go | 7 | Lily | 22 | 男 | 165 | 4 | | 5 | C++ | 7 | Lily | 22 | 男 | 165 | 4 | | 1 | Java | 8 | Susan | 23 | 男 | 170 | 5 | | 2 | MySQL | 8 | Susan | 23 | 男 | 170 | 5 | | 3 | Python | 8 | Susan | 23 | 男 | 170 | 5 | | 4 | Go | 8 | Susan | 23 | 男 | 170 | 5 | | 5 | C++ | 8 | Susan | 23 | 男 | 170 | 5 | | 1 | Java | 9 | Thomas | 22 | 女 | 178 | 5 | | 2 | MySQL | 9 | Thomas | 22 | 女 | 178 | 5 | | 3 | Python | 9 | Thomas | 22 | 女 | 178 | 5 | | 4 | Go | 9 | Thomas | 22 | 女 | 178 | 5 | | 5 | C++ | 9 | Thomas | 22 | 女 | 178 | 5 | | 1 | Java | 10 | Tom | 23 | 女 | 165 | 5 | | 2 | MySQL | 10 | Tom | 23 | 女 | 165 | 5 | | 3 | Python | 10 | Tom | 23 | 女 | 165 | 5 | | 4 | Go | 10 | Tom | 23 | 女 | 165 | 5 | | 5 | C++ | 10 | Tom | 23 | 女 | 165 | 5 | +----+-------------+----+--------+------+------+--------+-----------+ 50 rows in set (0.00 sec) 由运行结果可以看出，tb_course 和 tb_students_info 表交叉连接查询后，返回了 50 条记录。可以想象，当表中的数据较多时，得到的运行结果会非常长，而且得到的运行结果也没太大的意义。所以，通过交叉连接的方式进行多表查询的这种方法并不常用，我们应该尽量避免这种查询。 例 2 查询 tb_course 表中的 id 字段和 tb_students_info 表中的 course_id 字段相等的内容， SQL 语句和运行结果如下： mysql> SELECT * FROM tb_course CROSS JOIN tb_students_info -> WHERE tb_students_info.course_id = tb_course.id; +----+-------------+----+--------+------+------+--------+-----------+ | id | course_name | id | name | age | sex | height | course_id | +----+-------------+----+--------+------+------+--------+-----------+ | 1 | Java | 1 | Dany | 25 | 男 | 160 | 1 | | 2 | MySQL | 2 | Green | 23 | 男 | 158 | 2 | | 1 | Java | 3 | Henry | 23 | 女 | 185 | 1 | | 3 | Python | 4 | Jane | 22 | 男 | 162 | 3 | | 2 | MySQL | 5 | Jim | 24 | 女 | 175 | 2 | | 4 | Go | 6 | John | 21 | 女 | 172 | 4 | | 4 | Go | 7 | Lily | 22 | 男 | 165 | 4 | | 5 | C++ | 8 | Susan | 23 | 男 | 170 | 5 | | 5 | C++ | 9 | Thomas | 22 | 女 | 178 | 5 | | 5 | C++ | 10 | Tom | 23 | 女 | 165 | 5 | +----+-------------+----+--------+------+------+--------+-----------+ 10 rows in set (0.01 sec) 如果在交叉连接时使用 WHERE 子句，MySQL 会先生成两个表的笛卡尔积，然后再选择满足 WHERE 条件的记录。因此，表的数量较多时，交叉连接会非常非常慢。一般情况下不建议使用交叉连接。 在 MySQL 中，多表查询一般使用内连接和外连接，它们的效率要高于交叉连接。 笛卡尔积 笛卡尔积（Cartesian product）是指两个集合 X 和 Y 的乘积。 例如，有 A 和 B 两个集合，它们的值如下： A = {1,2} B = {3,4,5} 集合 A×B 和 B×A 的结果集分别表示为： A×B={(1,3), (1,4), (1,5), (2,3), (2,4), (2,5) }; B×A={(3,1), (3,2), (4,1), (4,2), (5,1), (5,2) }; 以上 A×B 和 B×A 的结果就叫做两个集合的笛卡尔积。 并且，从以上结果我们可以看出： 两个集合相乘，不满足交换率，即 A×B≠B×A。 A 集合和 B 集合的笛卡尔积是 A 集合的元素个数 × B 集合的元素个数。 多表查询遵循的算法就是以上提到的笛卡尔积，表与表之间的连接可以看成是在做乘法运算。在实际应用中，应避免使用笛卡尔积，因为笛卡尔积中容易存在大量的不合理数据，简单来说就是容易导致查询结果重复、混乱。 Update time： 2020-08-18 "},"MySQL/语句/INNER JOIN语句.html":{"url":"MySQL/语句/INNER JOIN语句.html","title":"INNER JOIN语句","keywords":"","body":"INNER JOIN语句 INNER JOIN：内连接 内连接（INNER JOIN）主要通过设置连接条件的方式，来移除查询结果中某些数据行的交叉连接。简单来说，就是利用条件表达式来消除交叉连接的某些数据行。 内连接使用 INNER JOIN 关键字连接两张表，并使用 ON 子句来设置连接条件。如果没有连接条件，INNER JOIN 和 CROSS JOIN 在语法上是等同的，两者可以互换。 内连接的语法格式如下： SELECT FROM INNER JOIN [ON子句] 语法说明如下。 字段名：需要查询的字段名称。 ：需要内连接的表名。 INNER JOIN ：内连接中可以省略 INNER 关键字，只用关键字 JOIN。 ON 子句：用来设置内连接的连接条件。 INNER JOIN 也可以使用 WHERE 子句指定连接条件，但是 INNER JOIN ... ON 语法是官方的标准写法，而且 WHERE 子句在某些时候会影响查询的性能。 多个表内连接时，在 FROM 后连续使用 INNER JOIN 或 JOIN 即可。 首先有2张表 “内连接”join，其实就是“inner join”，为了简写才写成join，两个是表示一个的，内连接，表示以两个表的交集为主，查出来是两个表有交集的部分，其余没有关联就不额外显示出来 内连接可以查询两个或两个以上的表。为了让大家更好的理解，暂时只讲解两个表的连接查询。 例 1 在 tb_students_info 表和 tb_course 表之间，使用内连接查询学生姓名和相对应的课程名称，SQL 语句和运行结果如下。 mysql> SELECT s.name,c.course_name ->FROM tb_students_info s ->INNER JOIN tb_course c -> ON s.course_id = c.id; +--------+-------------+ | name | course_name | +--------+-------------+ | Dany | Java | | Green | MySQL | | Henry | Java | | Jane | Python | | Jim | MySQL | | John | Go | | Lily | Go | | Susan | C++ | | Thomas | C++ | | Tom | C++ | +--------+-------------+ 10 rows in set (0.00 sec) 在这里的查询语句中，两个表之间的关系通过 INNER JOIN 指定，连接的条件使用 ON 子句给出。 假设使用INNER JOIN子句连接两个表：t1和t2， SELECT column_list FROM t1 INNER JOIN t2 ON join_condition; 对于t1表中的每一行，INNER JOIN子句将它与t2表的每一行进行比较，以检查它们是否都满足连接条件。当满足连接条件时，INNER JOIN将返回由t1和t2表中的列组成的新行。 请注意，t1和t2表中的行必须根据连接条件进行匹配。如果找不到匹配项，查询将返回一个空结果集。当连接超过2个表时，也应用此逻辑。 以下维恩图说明了INNER JOIN子句的工作原理。结果集中的行必须出现在两个表中：t1和t2，如两个圆的交叉部分所示 注意：当对多个表进行查询时，要在 SELECT 语句后面指定字段是来源于哪一张表。因此，在多表查询时，SELECT 语句后面的写法是表名.列名。另外，如果表名非常长的话，也可以给表设置别名，这样就可以直接在 SELECT 语句后面写上表的别名.列名。 Update time： 2020-08-18 "},"MySQL/语句/LEFT JOIN语句.html":{"url":"MySQL/语句/LEFT JOIN语句.html","title":"LEFT JOIN语句","keywords":"","body":"LEFT JOIN语句 左连接 左外连接又称为左连接，使用LEFT OUTER JOIN关键字连接两个表，并使用 ON 子句来设置连接条件。 左连接的语法格式如下： SELECT FROM LEFT OUTER JOIN 语法说明如下。 字段名：需要查询的字段名称。 ：需要左连接的表名。 LEFT OUTER JOIN：左连接中可以省略 OUTER 关键字，只使用关键字 LEFT JOIN。 ON 子句：用来设置左连接的连接条件，不能省略。 上述语法中，“表1”为基表，“表2”为参考表。左连接查询时，可以查询出“表1”中的所有记录和“表2”中匹配连接条件的记录。如果“表1”的某行在“表2”中没有匹配行，那么在返回结果中，“表2”的字段值均为空值（NULL）。 案例 select * from pd where user_id=1; select * from (select convert(log_time, date) day1, user_id, oprt_type from pd) a left join (select convert(log_time, date) day2, user_id, oprt_type from pd) b on b.user_id = a.user_id where a.user_id=1; Update time： 2020-09-09 "},"MySQL/语句/RIGHT JOIN语句.html":{"url":"MySQL/语句/RIGHT JOIN语句.html","title":"RIGHT JOIN语句","keywords":"","body":"RIGHT JOIN语句 右连接 右外连接又称为右连接，右连接是左连接的反向连接。使用 RIGHT OUTER JOIN 关键字连接两个表，并使用 ON子句来设置连接条件。 右连接的语法格式如下： SELECT FROM RIGHT OUTER JOIN 语法说明如下。 字段名：需要查询的字段名称。 ：需要右连接的表名。 RIGHT OUTER JOIN：右连接中可以省略 OUTER 关键字，只使用关键字 RIGHT JOIN。 ON 子句：用来设置右连接的连接条件，不能省略。 与左连接相反，右连接以“表2”为基表，“表1”为参考表。右连接查询时，可以查询出“表2”中的所有记录和“表1”中匹配连接条件的记录。如果“表2”的某行在“表1”中没有匹配行，那么在返回结果中，“表1”的字段值均为空值（NULL）。 “右连接”，表1右连接表2，以右为主，表示以表2为主，关联查询表1的数据，查出表2所有数据以及表1和表2有交集的数据 从score表中找出，没有在subjects表中出现过的记录 例 2 在 tb_students_info 表和 tb_course 表中查询所有课程，包括没有学生的课程，SQL 语句和运行结果如下。 mysql> SELECT s.name,c.course_name FROM tb_students_info s RIGHT OUTER JOIN tb_course c -> ON s.`course_id`=c.`id`; +--------+-------------+ | name | course_name | +--------+-------------+ | Dany | Java | | Green | MySQL | | Henry | Java | | Jane | Python | | Jim | MySQL | | John | Go | | Lily | Go | | Susan | C++ | | Thomas | C++ | | Tom | C++ | | NULL | HTML | +--------+-------------+ 11 rows in set (0.00 sec) 可以看到，结果显示了 11 条记录，名称为 HTML 的课程目前没有学生，因为对应的 tb_students_info 表中并没有该学生的信息，所以该条记录只取出了 tb_course 表中相应的值，而从 tb_students_info 表中取出的值为 NULL。 多个表左/右连接时，在 ON 子句后连续使用 LEFT/RIGHT OUTER JOIN 或 LEFT/RIGHT JOIN 即可。 使用外连接查询时，一定要分清需要查询的结果，是需要显示左表的全部记录还是右表的全部记录，然后选择相应的左连接和右连接。 Update time： 2020-09-10 "},"MySQL/语句/JOIN总结.html":{"url":"MySQL/语句/JOIN总结.html","title":"JOIN总结","keywords":"","body":"JOIN总结 不同类型的SQL JOIN 以下是SQL中不同类型的JOIN： （INNER）JOIN：返回两个表中具有匹配值的记录 LEFT（OUTER）JOIN：返回左表中的所有记录，以及右表中的匹配记录 RIGHT（OUTER）JOIN：返回右表中的所有记录，以及左表中匹配的记录 FULL（OUTER）JOIN：当左表或右表中匹配时返回所有记录 Update time： 2020-08-19 "},"MySQL/语句/UNION[ALL]运算符.html":{"url":"MySQL/语句/UNION[ALL]运算符.html","title":"UNION[ALL]运算符","keywords":"","body":"UNION[ALL]运算符 UNION 运算符 UNION运算符用于组合两个或多个 SELECT语句的结果集。 UNION中的每个SELECT语句必须具有相同的列数 列还必须具有类似的数据类型 每个SELECT语句中的列也必须具有相同的顺序, 列名必须相同。 UNION 本身是去重的。 SELECT column_name(s) FROM table1 UNION SELECT column_name(s) FROM table2; UNION ALL语法 UNION运算符默认情况下仅选择不同的值。要允许重复值，请使用UNION ALL： SELECT column_name(s) FROM table1 UNION ALL SELECT column_name(s) FROM table2; 注意：结果集中的列名通常等于UNION中第一个SELECT语句中的列名。 UNION与WHERE 以下SQL语句从“Customers”和“Suppliers”表中返回 Country = 'Germany'（仅限不同的值）： SELECT City, Country FROM Customers WHERE Country='Germany' UNION SELECT City, Country FROM Suppliers WHERE Country='Germany' ORDER BY City; UNION ALL使用WHERE 以下SQL语句从“Customers”和“Suppliers”表中返回 Country = 'Germany'（也是重复值）： SELECT City, Country FROM Customers WHERE Country='Germany' UNION ALL SELECT City, Country FROM Suppliers WHERE Country='Germany' ORDER BY City; Update time： 2020-08-19 "},"MySQL/语句/IN[NOT]IN语句.html":{"url":"MySQL/语句/IN[NOT]IN语句.html","title":"IN[NOT] IN语句","keywords":"","body":"IN[NOT] IN语句 MySQL 子查询 子查询是 MySQL 中比较常用的查询方法，通过子查询可以实现多表查询。子查询指将一个查询语句嵌套在另一个查询语句中。子查询可以在 SELECT、UPDATE 和 DELETE 语句中使用，而且可以进行多层嵌套。在实际开发时，子查询经常出现在 WHERE 子句中。 子查询在 WHERE 中的语法格式如下： WHERE (子查询) 其中，操作符可以是比较运算符和 IN、NOT IN、EXISTS、NOT EXISTS等关键字。 1）IN | NOT IN 当表达式与子查询返回的结果集中的某个值相等时，返回 TRUE，否则返回 FALSE；若使用关键字 NOT，则返回值正好相反。 IN 操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN 取一组由逗号分割、括在圆括号中的和合法值。 -- 42、查询每门功成绩最好的前两名 select t.c_id, t.s_score, t.r from ( select *, row_number() over (partition by c_id order by s_score desc ) r from score ) t where t.r in (1, 2); 2）EXISTS | NOT EXISTS 用于判断子查询的结果集是否为空，若子查询的结果集不为空，返回 TRUE，否则返回 FALSE；若使用关键字 NOT，则返回的值正好相反。 例 1 使用子查询在 tb_students_info 表和 tb_course 表中查询学习 Java 课程的学生姓名，SQL 语句和运行结果如下。 mysql> SELECT name FROM tb_students_info -> WHERE course_id IN ->(SELECT id FROM tb_course WHERE course_name = 'Java'); +-------+ | name | +-------+ | Dany | | Henry | +-------+ 2 rows in set (0.01 sec) 结果显示，学习 Java 课程的只有 Dany 和 Henry。上述查询过程也可以分为以下 2 步执行，实现效果是相同的。 1）首先单独执行内查询，查询出 tb_course 表中课程为 Java 的 id，SQL 语句和运行结果如下。 mysql> SELECT id FROM tb_course -> WHERE course_name = 'Java'; +----+ | id | +----+ | 1 | +----+ 1 row in set (0.00 sec) 可以看到，符合条件的 id 字段的值为 1。 2）然后执行外层查询，在 tb_students_info 表中查询 course_id 等于 1 的学生姓名。SQL 语句和运行结果如下。 mysql> SELECT name FROM tb_students_info -> WHERE course_id IN (1); +-------+ | name | +-------+ | Dany | | Henry | +-------+ 2 rows in set (0.00 sec) 习惯上，外层的 SELECT 查询称为父查询，圆括号中嵌入的查询称为子查询（子查询必须放在圆括号内）。MySQL 在处理上例的 SELECT 语句时，执行流程为：先执行子查询，再执行父查询。 例 2 与例 1 类似，在 SELECT 语句中使用 NOT IN 关键字，查询没有学习 Java 课程的学生姓名，SQL 语句和运行结果如下。 mysql> SELECT name FROM tb_students_info -> WHERE course_id NOT IN (SELECT id FROM tb_course WHERE course_name = 'Java'); +--------+ | name | +--------+ | Green | | Jane | | Jim | | John | | Lily | | Susan | | Thomas | | Tom | | LiMing | +--------+ 9 rows in set (0.01 sec) 可以看出，运行结果与例 1 刚好相反，没有学习 Java 课程的是除了 Dany 和 Henry 之外的学生。 例 3 使用=运算符，在 tb_course 表和 tb_students_info 表中查询出所有学习 Python 课程的学生姓名，SQL 语句和运行结果如下。 结果如下。 mysql> SELECT name FROM tb_students_info -> WHERE course_id = ->(SELECT id FROM tb_course WHERE course_name = 'Python'); +------+ | name | +------+ | Jane | +------+ 1 row in set (0.00 sec) 结果显示，学习 Python 课程的学生只有 Jane。 例 4 使用<>运算符，在 tb_course 表和 tb_students_info 表中查询出没有学习 Python 课程的学生姓名，SQL 语句和运行结果如下。 mysql> SELECT name FROM tb_students_info -> WHERE course_id <> ->(SELECT id FROM tb_course WHERE course_name = 'Python'); +--------+ | name | +--------+ | Dany | | Green | | Henry | | Jim | | John | | Lily | | Susan | | Thomas | | Tom | | LiMing | +--------+ 10 rows in set (0.00 sec) 可以看出，运行结果与例 3 刚好相反，没有学习 Python 课程的是除了 Jane 之外的学生。 例 5 查询 tb_course 表中是否存在 id=1 的课程，如果存在，就查询出 tb_students_info 表中的记录，SQL 语句和运行结果如下。 mysql> SELECT * FROM tb_students_info -> WHERE EXISTS ->(SELECT course_name FROM tb_course WHERE id=1); +----+--------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+--------+------+------+--------+-----------+ | 1 | Dany | 25 | 男 | 160 | 1 | | 2 | Green | 23 | 男 | 158 | 2 | | 3 | Henry | 23 | 女 | 185 | 1 | | 4 | Jane | 22 | 男 | 162 | 3 | | 5 | Jim | 24 | 女 | 175 | 2 | | 6 | John | 21 | 女 | 172 | 4 | | 7 | Lily | 22 | 男 | 165 | 4 | | 8 | Susan | 23 | 男 | 170 | 5 | | 9 | Thomas | 22 | 女 | 178 | 5 | | 10 | Tom | 23 | 女 | 165 | 5 | | 11 | LiMing | 22 | 男 | 180 | 7 | +----+--------+------+------+--------+-----------+ 11 rows in set (0.01 sec) 由结果可以看到，tb_course 表中存在 id=1 的记录，因此 EXISTS 表达式返回 TRUE，外层查询语句接收 TRUE 之后对表 tb_students_info 进行查询，返回所有的记录。 EXISTS 关键字可以和其它查询条件一起使用，条件表达式与 EXISTS 关键字之间用 AND 和 OR 连接。 例 6 查询 tb_course 表中是否存在 id=1 的课程，如果存在，就查询出 tb_students_info 表中 age 字段大于 24 的记录，SQL 语句和运行结果如下。 mysql> SELECT * FROM tb_students_info -> WHERE age>24 AND ->EXISTS(SELECT course_name FROM tb_course WHERE id=1); +----+------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+------+------+------+--------+-----------+ | 1 | Dany | 25 | 男 | 160 | 1 | +----+------+------+------+--------+-----------+ 1 row in set (0.01 sec) 结果显示，从 tb_students_info 表中查询出了一条记录，这条记录的 age 字段取值为 25。内层查询语句从 tb_course 表中查询到记录，返回 TRUE。外层查询语句开始进行查询。根据查询条件，从 tb_students_info 表中查询 age 大于 24 的记录。 在完成较复杂的数据查询时，经常会使用到子查询，编写子查询语句时，要注意如下事项。 子查询语句可以嵌套在 SQL 语句中任何表达式出现的位置 在 SELECT 语句中，子查询可以被嵌套在 SELECT 语句的列、表和查询条件中，即 SELECT 子句，FROM 子句、WHERE 子句、GROUP BY 子句和 HAVING 子句。 前面已经介绍了 WHERE 子句中嵌套子查询的使用方法，下面是子查询在 SELECT 子句和 FROM 子句中的使用语法。 嵌套在 SELECT 语句的 SELECT 子句中的子查询语法格式如下。 SELECT (子查询) FROM 表名; 提示：子查询结果为单行单列，但不必指定列别名。 嵌套在 SELECT 语句的 FROM 子句中的子查询语法格式如下。 SELECT * FROM (子查询) AS 表的别名; 注意：必须为表指定别名。一般返回多行多列数据记录，可以当作一张临时表。 只出现在子查询中而没有出现在父查询中的表不能包含在输出列中 多层嵌套子查询的最终数据集只包含父查询（即最外层的查询）的 SELECT 子句中出现的字段，而子查询的输出结果通常会作为其外层子查询数据源或用于数据判断匹配。 常见错误如下： SELECT * FROM (SELECT * FROM result); 这个子查询语句产生语法错误的原因在于主查询语句的 FROM 子句是一个子查询语句，因此应该为子查询结果集指定别名。正确代码如下。 SELECT * FROM (SELECT * FROM result) AS Temp; Update time： 2020-08-18 "},"MySQL/语句/IN[NOT]EXISTS语句.html":{"url":"MySQL/语句/IN[NOT]EXISTS语句.html","title":"IN[NOT] EXISTS语句","keywords":"","body":"IN[NOT] EXISTS语句 Update time： 2020-08-18 "},"MySQL/语句/REGEXP：正则表达式.html":{"url":"MySQL/语句/REGEXP：正则表达式.html","title":"REGEXP：正则表达式","keywords":"","body":"REGEXP：正则表达式 REGEXP：正则表达式 正则表达式主要用来查询和替换符合某个模式（规则）的文本内容。例如，从一个文件中提取电话号码，查找一篇文章中重复的单词、替换文章中的敏感语汇等，这些地方都可以使用正则表达式。正则表达式强大且灵活，常用于非常复杂的查询。 MySQL 中，使用 REGEXP 关键字指定正则表达式的字符匹配模式，其基本语法格式如下： 属性名 REGEXP '匹配方式' 其中，“属性名”表示需要查询的字段名称；“匹配方式”表示以哪种方式来匹配查询。“匹配方式”中有很多的模式匹配字符，它们分别表示不同的意思。下表列出了 REGEXP 操作符中常用的匹配方式。 选项 说明 例子 匹配值示例 ^ 匹配文本的开始字符 '^b' 匹配以字母 b 开头的字符串 book、big、banana、bike $ 匹配文本的结束字符 'st$' 匹配以 st 结尾的字符串 test、resist、persist . 匹配任何单个字符 'b.t' 匹配任何 b 和 t 之间有一个字符 bit、bat、but、bite * 匹配零个或多个在它前面的字符 'f*n' 匹配字符 n 前面有任意个字符 f fn、fan、faan、abcn + 匹配前面的字符 1 次或多次 'ba+' 匹配以 b 开头，后面至少紧跟一个 a ba、bay、bare、battle 匹配包含指定字符的文本 'fa' 匹配包含‘fa’的文本 fan、afa、faad [字符集合] 匹配字符集合中的任何一个字符 '[xz]' 匹配 x 或者 z dizzy、zebra、x-ray、extra 匹配不在括号中的任何字符 'abc' 匹配任何不包含 a、b 或 c 的字符串 desk、fox、f8ke 字符串{n,} 匹配前面的字符串至少 n 次 'b{2}' 匹配 2 个或更多的 b bbb、bbbb、bbbbbbb 字符串 {n,m} 匹配前面的字符串至少 n 次， 至多 m 次 'b{2,4}' 匹配最少 2 个，最多 4 个 b bbb、bbbb MySQL 中的正则表达式与 Java 语言、PHP 语言等编程语言中的正则表达式基本一致。 查询以特定字符或字符串开头的记录 字符^用来匹配以特定字符或字符串开头的记录。 例 1 在 tb_students_info 表中，查询 name 字段以“J”开头的记录，SQL 语句和执行过程如下。 mysql> SELECT * FROM tb_students_info -> WHERE name REGEXP '^J'; +----+------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+------+------+------+--------+-----------+ | 4 | Jane | 22 | 男 | 162 | 3 | | 5 | Jim | 24 | 女 | 175 | 2 | | 6 | John | 21 | 女 | 172 | 4 | +----+------+------+------+--------+-----------+ 3 rows in set (0.01 sec) 例 2 在 tb_students_info 表中，查询 name 字段以“Ji”开头的记录，SQL 语句和执行过程如下。 mysql> SELECT * FROM tb_students_info -> WHERE name REGEXP '^Ji'; +----+------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+------+------+------+--------+-----------+ | 5 | Jim | 24 | 女 | 175 | 2 | +----+------+------+------+--------+-----------+ 1 row in set (0.00 sec) 查询以特定字符或字符串结尾的记录 字符$用来匹配以特定字符或字符串结尾的记录。 例 3 在 tb_students_info 表中，查询 name 字段以“y”结尾的记录，SQL 语句和执行过程如下。 mysql> SELECT * FROM tb_students_info -> WHERE name REGEXP 'y$'; +----+-------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+-------+------+------+--------+-----------+ | 1 | Dany | 25 | 男 | 160 | 1 | | 3 | Henry | 23 | 女 | 185 | 1 | | 7 | Lily | 22 | 男 | 165 | 4 | +----+-------+------+------+--------+-----------+ 3 rows in set (0.00 sec) 例 4 在 tb_students_info 表中，查询 name 字段以“ry”结尾的记录，SQL 语句和执行过程如下。 mysql> SELECT * FROM tb_students_info -> WHERE name REGEXP 'ry$'; +----+-------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+-------+------+------+--------+-----------+ | 3 | Henry | 23 | 女 | 185 | 1 | +----+-------+------+------+--------+-----------+ 1 row in set (0.00 sec) 替代字符串中的任意一个字符 字符.用来替代字符串中的任意一个字符。 例 5 在 tb_students_info 表中，查询 name 字段值包含“a”和“y”，且两个字母之间只有一个字母的记录，SQL 语句和执行过程如下。 mysql> SELECT * FROM tb_students_info -> WHERE name REGEXP 'a.y'; +----+------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+------+------+------+--------+-----------+ | 1 | Dany | 25 | 男 | 160 | 1 | +----+------+------+------+--------+-----------+ 1 row in set (0.00 sec) 匹配多个字符 字符*和+都可以匹配多个该符号之前的字符。不同的是，+表示至少一个字符，而*可以表示 0 个字符。 例 6 在 tb_students_info 表中，查询 name 字段值包含字母“T”，且“T”后面出现字母“h”的记录，SQL 语句和执行过程如下。 mysql> SELECT * FROM tb_students_info -> WHERE name REGEXP '^Th*'; +----+--------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+--------+------+------+--------+-----------+ | 9 | Thomas | 22 | 女 | 178 | 5 | | 10 | Tom | 23 | 女 | 165 | 5 | +----+--------+------+------+--------+-----------+ 2 rows in set (0.00 sec) 例 7 在 tb_students_info 表中，查询 name 字段值包含字母“T”，且“T”后面至少出现“h”一次的记录，SQL 语句和执行过程如下。 mysql> SELECT * FROM tb_students_info -> WHERE name REGEXP '^Th+'; +----+--------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+--------+------+------+--------+-----------+ | 9 | Thomas | 22 | 女 | 178 | 5 | +----+--------+------+------+--------+-----------+ 1 row in set (0.00 sec) 匹配指定字符串 正则表达式可以匹配字符串。当表中的记录包含这个字符串时，就可以将该记录查询出来。指定多个字符串时，需要用|隔开。只要匹配这些字符串中的任意一个即可。 例 8 在 tb_students_info 表中，查询 name 字段值包含字符串“an”的记录，SQL 语句和执行过程如下。 mysql> SELECT * FROM tb_students_info -> WHERE name REGEXP 'an'; +----+-------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+-------+------+------+--------+-----------+ | 1 | Dany | 25 | 男 | 160 | 1 | | 4 | Jane | 22 | 男 | 162 | 3 | | 8 | Susan | 23 | 男 | 170 | 5 | +----+-------+------+------+--------+-----------+ 3 rows in set (0.00 sec) 例 9 在 tb_students_info 表中，查询 name 字段值包含字符串“an”或“en”的记录，SQL 语句和执行过程如下。 mysql> SELECT * FROM tb_students_info -> WHERE name REGEXP 'an|en'; +----+-------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+-------+------+------+--------+-----------+ | 1 | Dany | 25 | 男 | 160 | 1 | | 2 | Green | 23 | 男 | 158 | 2 | | 3 | Henry | 23 | 女 | 185 | 1 | | 4 | Jane | 22 | 男 | 162 | 3 | | 8 | Susan | 23 | 男 | 170 | 5 | +----+-------+------+------+--------+-----------+ 5 rows in set (0.00 sec) 注意：字符串与|之间不能有空格。因为，查询过程中，数据库系统会将空格也当作一个字符，这样就查询不出想要的结果。 匹配指定字符串中的任意一个 使用方括号[ ]可以将需要查询的字符组成一个字符集合。只要记录中包含方括号中的任意字符，该记录就会被查询出来。例如，通过“[abc]”可以查询包含 a、b 和 c 等 3 个字母中任意一个的记录。 例 10 在 tb_students_info 表中，查询 name 字段值包含字母“i”或“o”的记录，SQL 语句和执行过程如下。 mysql> SELECT * FROM tb_students_info -> WHERE name REGEXP '[io]'; +----+--------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+--------+------+------+--------+-----------+ | 5 | Jim | 24 | 女 | 175 | 2 | | 6 | John | 21 | 女 | 172 | 4 | | 7 | Lily | 22 | 男 | 165 | 4 | | 9 | Thomas | 22 | 女 | 178 | 5 | | 10 | Tom | 23 | 女 | 165 | 5 | | 11 | LiMing | 22 | 男 | 180 | 7 | +----+--------+------+------+--------+-----------+ 6 rows in set (0.00 sec) 从查询结果可以看到，所有返回记录的 name 字段值都包含字母 i 或 o，或者两个都有。 方括号[ ]还可以指定集合的区间。例如，“[a-z]”表示从 a~z 的所有字母；“[0-9]”表示从 0~9 的所有数字；“[a-z0-9]”表示包含所有的小写字母和数字；“[a-zA-Z]”表示匹配所有字符。 例 11 在 tb_students_info 表中，查询 name 字段值中包含 1、2 或 3 的记录，SQL 语句和执行过程如下。 mysql> SELECT * FROM tb_students_info -> WHERE name REGEXP '[123]'; Empty set (0.00 sec) 匹配集合“[123]”也可以写成“[1-3]”，即指定集合区间。 匹配指定字符以外的字符 [^字符集合]用来匹配不在指定集合中的任何字符。 例 12 在 tb_students_info 表中，查询 name 字段值包含字母 a~t 以外的字符的记录，SQL 语句和执行过程如下。 mysql> SELECT * FROM tb_students_info -> WHERE name REGEXP '[^a-t]' ; +----+-------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+-------+------+------+--------+-----------+ | 1 | Dany | 25 | 男 | 160 | 1 | | 3 | Henry | 23 | 女 | 185 | 1 | | 7 | Lily | 22 | 男 | 165 | 4 | | 8 | Susan | 23 | 男 | 170 | 5 | +----+-------+------+------+--------+-----------+ 4 rows in set (0.00 sec) 使用{n,}或者{n,m}来指定字符串连续出现的次数 字符串{n,}表示字符串连续出现 n 次；字符串{n,m}表示字符串连续出现至少 n 次，最多 m 次。 例如，a{2,} 表示字母 a 连续出现至少 2 次，也可以大于 2 次；a{2,4} 表示字母 a 连续出现最少 2 次，最多不能超过 4 次。 例 13 在 tb_students_info 表中，查询 name 字段值出现字母‘e’ 至少 2 次的记录，SQL 语句如下： mysql> SELECT * FROM tb_students_info WHERE name REGEXP 'e{2,}'; +----+-------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+-------+------+------+--------+-----------+ | 2 | Green | 23 | 男 | 158 | 2 | +----+-------+------+------+--------+-----------+ 1 row in set (0.00 sec) 例 14 在 tb_students_info 表中，查询 name 字段值出现字符串“i” 最少 1 次，最多 3 次的记录，SQL 语句如下： mysql> SELECT * FROM tb_students_info WHERE name REGEXP 'i{1,3}'; +----+--------+------+------+--------+-----------+ | id | name | age | sex | height | course_id | +----+--------+------+------+--------+-----------+ | 5 | Jim | 24 | 女 | 175 | 2 | | 7 | Lily | 22 | 男 | 165 | 4 | | 11 | LiMing | 22 | 男 | 180 | 7 | +----+--------+------+------+--------+-----------+ 3 rows in set (0.00 sec) Update time： 2020-08-18 "},"MySQL/语句/DELETE语句.html":{"url":"MySQL/语句/DELETE语句.html","title":"DELETE语句","keywords":"","body":"DELETE语句 DELETE：删除数据 删除单个表中的数据 使用 DELETE 语句从单个表中删除数据，语法格式为： DELETE FROM [WHERE 子句] [ORDER BY 子句] [LIMIT 子句] 语法说明如下： ：指定要删除数据的表名。 ORDER BY 子句：可选项。表示删除时，表中各行将按照子句中指定的顺序进行删除。 WHERE 子句：可选项。表示为删除操作限定删除条件，若省略该子句，则代表删除该表中的所有行。 LIMIT 子句：可选项。用于告知服务器在控制命令被返回到客户端前被删除行的最大值。 注意：在不使用 WHERE 条件的时候，将删除所有数据。 删除表中的全部数据 【实例 1】删除 tb_courses_new 表中的全部数据，输入的 SQL 语句和执行结果如下所示。 mysql> DELETE FROM tb_courses_new; Query OK, 3 rows affected (0.12 sec) mysql> SELECT * FROM tb_courses_new; Empty set (0.00 sec) 根据条件删除表中的数据 【实例 2】在 tb_courses_new 表中，删除 course_id 为 4 的记录，输入的 SQL 语句和执行结果如下所示。 mysql> DELETE FROM tb_courses -> WHERE course_id=4; Query OK, 1 row affected (0.00 sec) mysql> SELECT * FROM tb_courses; +-----------+-------------+--------------+------------------+ | course_id | course_name | course_grade | course_info | +-----------+-------------+--------------+------------------+ | 1 | Network | 3 | Computer Network | | 2 | Database | 3 | MySQL | | 3 | Java | 4 | Java EE | +-----------+-------------+--------------+------------------+ 3 rows in set (0.00 sec) 由运行结果可以看出，course_id 为 4 的记录已经被删除。 案例 196. 删除重复的电子邮箱 [简单] 编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。 Id Email 1 john@example.com 2 bob@example.com 3 john@example.com Id 是这个表的主键。 例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行: Id Email 1 john@example.com 2 bob@example.com 提示： 执行 SQL 之后，输出是整个 Person 表。 使用 delete 语句。 解题 方法一 DELETE p1 FROM Person p1, Person p2 WHERE p1.Email = p2.Email AND p1.Id > p2.Id 分析： 1、DELETE p1 在 DELETE官方文档中，给出了这一用法，比如下面这个DELETE语句👇 DELETE t1 FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL; 这种 DELETE 方式很陌生，竟然和 SELETE 的写法类似。它涉及到 t1 和 t2 两张表，DELETE t1表示要删除 t1的一些记录，具体删哪些，就看 WHERE条件，满足就删；这里删的是 t1 表中，跟 t2 匹配不上的那些记录。 Update time： 2020-08-19 "},"MySQL/语句/TRUNCATE语句.html":{"url":"MySQL/语句/TRUNCATE语句.html","title":"TRUNCATE语句","keywords":"","body":"TRUNCATE语句 TRUNCATE：清空表记录 MySQL 提供了 DELETE 和 TRUNCATE 关键字来删除表中的数据。本节主要讲解 TRUNCATE 关键字的使用。 TRUNCATE 关键字用于完全清空一个表。其语法格式如下： TRUNCATE [TABLE] 表名 其中，TABLE 关键字可省略。 例 1 新建表 tb_student_course，插入数据并查询，SQL 语句和运行结果如下： mysql> CREATE TABLE `tb_student_course` ( -> `id` int(4) NOT NULL AUTO_INCREMENT, -> `name` varchar(25) NOT NULL, -> PRIMARY KEY (`id`) -> ); Query OK, 0 rows affected (0.04 sec) mysql> INSERT INTO tb_student_course(name) VALUES ('Java'),('MySQL'),('Python'); Query OK, 3 rows affected (0.05 sec) Records: 3 Duplicates: 0 Warnings: 0 mysql> SELECT * FROM tb_student_course; +----+--------+ | id | name | +----+--------+ | 1 | Java | | 2 | MySQL | | 3 | Python | +----+--------+ 3 rows in set (0.00 sec) 使用 TRUNCATE 语句清空 tb_student_course 表中的记录，SQL 语句和运行结果如下： mysql> TRUNCATE TABLE tb_student_course; Query OK, 0 rows affected (0.04 sec) mysql> SELECT * FROM tb_student_course; Empty set (0.00 sec) TRUNCATE 和 DELETE 的区别 从逻辑上说，TRUNCATE 语句与 DELETE 语句作用相同，但是在某些情况下，两者在使用上有所区别。 DELETE 是 DML 类型的语句；TRUNCATE 是 DDL 类型的语句。它们都用来清空表中的数据。 DELETE 是逐行一条一条删除记录的；TRUNCATE 则是直接删除原来的表，再重新创建一个一模一样的新表，而不是逐行删除表中的数据，执行数据比 DELETE 快。因此需要删除表中全部的数据行时，尽量使用 TRUNCATE 语句， 可以缩短执行时间。 DELETE 删除数据后，配合事件回滚可以找回数据；TRUNCATE 不支持事务的回滚，数据删除后无法找回。 DELETE 删除数据后，系统不会重新设置自增字段的计数器；TRUNCATE 清空表记录后，系统会重新设置自增字段的计数器。 DELETE 的使用范围更广，因为它可以通过 WHERE 子句指定条件来删除部分数据；而 TRUNCATE 不支持 WHERE 子句，只能删除整体。 DELETE 会返回删除数据的行数，但是 TRUNCATE 只会返回 0，没有任何意义。 总结 当不需要该表时，用 DROP；当仍要保留该表，但要删除所有记录时，用 TRUNCATE；当要删除部分记录时，用 DELETE。 1、处理效率：drop>trustcate>delete 2、drop删除整个表；trustcate删除全部记录，但不删除表；delete删除部分记录 3、delete不影响所用extent，高水线保持原位置不动；trustcate会将高水线复位。 Update time： 2020-08-18 "},"MySQL/语句/ANY和ALL运算符.html":{"url":"MySQL/语句/ANY和ALL运算符.html","title":"ANY和ALL运算符","keywords":"","body":"ANY和ALL运算符 ANY和ALL运算符与WHERE或HAVING子句一起使用。 如果任何子查询值满足条件，则ANY运算符返回true。 如果所有子查询值满足条件，则ALL运算符返回true。 ANY 语法 SELECT column_name(s) FROM table_name WHERE column_name operator ANY (SELECT column_name FROM table_name WHEREcondition); ALL 语法 SELECT column_name(s) FROM table_name WHERE column_name operator ALL (SELECT column_name FROM table_name WHERE condition); 注意：所述的操作符必须是标准比较运算符（=，<>，=，>，> =， 示例 我们新建两个表Test1和Test2 Test1表结构如下： Num 2 3 4 Test2表结构如下： Num 1 2 3 4 5 ALL使用示例 示例1 SELECT Num FROM Test2 WHERE Num > ALL (SELECT Num FROM Test1) 结果为： Num 5 从上面的结果我们可以看出，只有Test2中的5才是大于Test1中的所有数。 示例2 SELECT Num FROM Test2 WHERE Num 结果为： Num 1 从上面的结果我们可以看出，只有Test2中的1才是小于Test1中的所有数。 ANY/SOME使用示例 示例 SELECT Num FROM Test2 WHERE Num > ANY (SELECT Num FROM Test1) SELECT Num FROM Test2 WHERE Num > SOME (SELECT Num FROM Test1) 他们的结果均为： Num 3 4 5 从上面的结果我们可以看出，ANY和SOME是等价的，而且Test2中的任何一个数都满足大于Test1中的数。比如Test2中的3就大于2 \"=ANY\"与\"IN\"相同 示例 SELECT Num FROM Test2 WHERE Num = ANY (SELECT Num FROM Test1) SELECT Num FROM Test2 WHERE Num IN (SELECT Num FROM Test1) 他们的结果均为： Num 2 3 4 表示Test1中的任何一个数都存在于Test2中 \"<>ALL\"与\"NOT IN\"相同 示例 SELECT Num FROM Test2 WHERE Num <> ALL (SELECT Num FROM Test1) SELECT Num FROM Test2 WHERE Num NOT IN (SELECT Num FROM Test1) 他们的结果均为： Num 1 5 表示Test2中的结果都不存在与Test1中 这三个关键字不常用，但是如果遇到了知道是什么意思，怎么用就好了。 参考 SQL中的ALL、ANY和SOME的用法介绍 Update time： 2020-08-19 "},"MySQL/语句/DECLARE定义变量.html":{"url":"MySQL/语句/DECLARE定义变量.html","title":"DECLARE定义变量","keywords":"","body":"DECLARE定义变量 变量分文局部变量和全局变量 局部变量是@开头，全局变量是@@开头， 在 sql 中，定义一个变量需要关键字 DECLARE, 还需要个特殊符号标记（@）表示是变量。 看看简单的声明语法： Declare @Local_Var data_type; @Local_Var是一个整体，表示一个变量。 data_type就是数据类型了，这个大家都很熟悉的，例如int,decimal ,float,text等。 变量声明了，怎么赋值呢，能在声明的时候赋值么？像这样 declare @ID=2 varchar(20); 这样是不行的 但是这样呢 declare @ID varchar(20)=2 print @ID --这句话的意思是在sql server窗口中打印出变量的值 这样是正确的，结果是 --------- 2 声明可以赋值，再声明后是可以再赋值的， 这里有两种方式赋值 set, select ,先看基本用法，再说区别 基本用法 declare @ID varchar(20) --定义一个变量叫@ID set @ID=3 --变量赋值为3 print @ID --打印 select @ID=1 --变量赋值为1 print @ID --打印 查看结果 ------------- 3 1 从上面看出来了，Set,与select都可以给变量赋值。 然后我们看看变量的运算，运算其实很简单，下面看看加减法 declare @ID varchar(20) set @ID=3 print @ID select @ID=1+@ID --将变量@id加1 print @ID select @ID=(select 1+5) --类似于@ID=1+5 print @ID select @ID=(select 1-@ID) --类似于@ID=1-@ID print @ID 结果 ----------- 　　3 　　4 　　6 　 -5 区别 1，表达式返回多个值时 表达式返回多个值时，使用 SET 赋值 declare @name varchar(128) set @name=(select username from userinfo) print @name /* --出错信息为 服务器: 消息 512，级别 16，状态 1，行 2 子查询返回的值多于一个。当子查询跟随在 =、!=、、>= 之后，或子查询用作表达式时，这种情况是不允许的。 */ 表达式返回多个值时，使用 SELECT 赋值 declare @name varchar(20) select @name= username from userinfo print @name --结果集中最后一个 username 列的值 结果: --------- wangwu 2,表达式未返回值时 --表达式未返回值时，使用 SET 赋值 declare @name varchar(20) set @name='jack' set @name= (select username from userinfo where username='not') print @name --Null值 结果 -------- --表达式未返回值时，使用 SELECT 赋值 declare @name varchar(20) set @name='jack' select @name=username from userinfo where username='not' print @name --jack,保存原来的值 结果 ------- jack 下表列出 SET 与 SELECT 的区别。 参考 SQL 存储过程入门（变量） Update time： 2020-08-19 "},"MySQL/语句/创建临时表TEMPORARY.html":{"url":"MySQL/语句/创建临时表TEMPORARY.html","title":"创建临时表TEMPORARY","keywords":"","body":"创建临时表TEMPORARY 创建临时表 下面是创建临时表以及插入数据的例子 A、临时表再断开于mysql的连接后系统会自动删除临时表中的数据，但是这只限于用下面语句建立的表： 1)定义字段 CREATE TEMPORARY TABLE tmp_table ( name VARCHAR(10) NOT NULL, time date NOT NULL ); 更高级点就是： create temporary TABLE `temtable` ( `jws` varchar(100) character set utf8 collate utf8_bin NOT NULL, `tzlb` varchar(100) character set utf8 collate utf8_bin NOT NULL, `uptime` date NOT NULL ) ENGINE=InnoDB DEFAULT CHARSET=latin1″ 连编码方式都规定了。。呵呵，以防乱码啊。 2)直接将查询结果导入临时表 CREATE TEMPORARY TABLE tmp_table SELECT * FROM table_name; B、另外mysql也允许你在内存中直接创建临时表，因为是在内存中所有速度会很快，语法如下： CREATE TEMPORARY TABLE tmp_table ( name VARCHAR(10) NOT NULL, value INTEGER NOT NULL ) TYPE = HEAP 那如何将查询的结果存入已有的表呢？ 1、可以使用A中第二个方法 2、使用insert into temtable (select a,b,c,d from tablea); 首先，临时表只在当前连接可见，当关闭连接时，Mysql会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。 创建临时表的语法与创建表语法类似，不同之处是增加关键字 TEMPORARY，如： CREATE TEMPORARY TABLE 表名 (…. ) 删除临时表 临时表可以手动删除： DROP TEMPORARY TABLE IF EXISTS temp_tb; 参考 mysql创建临时表，将查询结果插入已有表中 Update time： 2020-09-08 "},"MySQL/语句/创建视图VIEW.html":{"url":"MySQL/语句/创建视图VIEW.html","title":"创建视图VIEW","keywords":"","body":"创建视图VIEW Q：什么是视图？视图是干什么用的？ A： 　　视图（view）是一种虚拟存在的表，是一个逻辑表，本身并不包含数据。作为一个select语句保存在数据字典中的。 　　通过视图，可以展现基表的部分数据；视图数据来自定义视图的查询中使用的表，使用视图动态生成。 基表：用来创建视图的表叫做基表base table Q：为什么要使用视图？ A：因为视图的诸多优点，如下 　　1）简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。 　　2）安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。 　　3）数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。 总而言之，使用视图的大部分情况是为了保障数据安全性，提高查询效率。 创建视图 CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION] 1）OR REPLACE：表示替换已有视图 2）ALGORITHM：表示视图选择算法，默认算法是 UNDEFINED(未定义的)：MySQL自动选择要使用的算法 ；merge合并；temptable临时表 3）select_statement：表示select语句 4）[WITH [CASCADED | LOCAL] CHECK OPTION]：表示视图在更新时保证在视图的权限范围之内 　　cascade是默认值，表示更新视图的时候，要满足视图和表的相关条件 　　local表示更新视图的时候，要满足该视图定义的一个条件即可 TIPS：推荐使用 WHIT [CASCADED|LOCAL] CHECK OPTION选项，可以保证数据的安全性 基本格式： create view [(column_list)] as select语句 with check option; 1、在单表上创建视图 mysql> create view v_F_players(编号,名字,性别,电话) -> as -> select PLAYERNO,NAME,SEX,PHONENO from PLAYERS -> where SEX='F' -> with check option; Query OK, 0 rows affected (0.00 sec) mysql> desc v_F_players; +--------+----------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +--------+----------+------+-----+---------+-------+ | 编号 | int(11) | NO | | NULL | | | 名字 | char(15) | NO | | NULL | | | 性别 | char(1) | NO | | NULL | | | 电话 | char(13) | YES | | NULL | | +--------+----------+------+-----+---------+-------+ 4 rows in set (0.00 sec) mysql> select * from v_F_players; +--------+-----------+--------+------------+ | 编号 | 名字 | 性别 | 电话 | +--------+-----------+--------+------------+ | 8 | Newcastle | F | 070-458458 | | 27 | Collins | F | 079-234857 | | 28 | Collins | F | 010-659599 | | 104 | Moorman | F | 079-987571 | | 112 | Bailey | F | 010-548745 | +--------+-----------+--------+------------+ 5 rows in set (0.02 sec) 1、在多表上创建视图 mysql> create view v_match -> as -> select a.PLAYERNO,a.NAME,MATCHNO,WON,LOST,c.TEAMNO,c.DIVISION -> from -> PLAYERS a,MATCHES b,TEAMS c -> where a.PLAYERNO=b.PLAYERNO and b.TEAMNO=c.TEAMNO; Query OK, 0 rows affected (0.03 sec) mysql> select * from v_match; +----------+-----------+---------+-----+------+--------+----------+ | PLAYERNO | NAME | MATCHNO | WON | LOST | TEAMNO | DIVISION | +----------+-----------+---------+-----+------+--------+----------+ | 6 | Parmenter | 1 | 3 | 1 | 1 | first | | 44 | Baker | 4 | 3 | 2 | 1 | first | | 83 | Hope | 5 | 0 | 3 | 1 | first | | 112 | Bailey | 12 | 1 | 3 | 2 | second | | 8 | Newcastle | 13 | 0 | 3 | 2 | second | +----------+-----------+---------+-----+------+--------+----------+ 5 rows in set (0.04 sec) 视图将我们不需要的数据过滤掉，将相关的列名用我们自定义的列名替换。视图作为一个访问接口，不管基表的表结构和表名有多复杂。 　如果创建视图时不明确指定视图的列名，那么列名就和定义视图的select子句中的列名完全相同； 　　如果显式的指定视图的列名就按照指定的列名。 注意：显示指定视图列名，要求视图名后面的列的数量必须匹配select子句中的列的数量。 参考 深入解析MySQL视图VIEW Update time： 2020-09-08 "},"MySQL/窗口函数/窗口函数.html":{"url":"MySQL/窗口函数/窗口函数.html","title":"窗口函数","keywords":"","body":"窗口函数 MySQL 窗口函数 简介：在本教程中，您将了解MySQL窗口函数及其在解决分析查询挑战中的有用应用。 从版本8.0开始，MySQL支持窗口函数。窗口函数允许您以新的，更简单的方式解决查询问题，并具有更好的性能。 假设我们有一个sales表，按员工和财政年度存储销售额，如下所示： CREATE TABLE sales( sales_employee VARCHAR(50) NOT NULL, fiscal_year INT NOT NULL, sale DECIMAL(14,2) NOT NULL, PRIMARY KEY(sales_employee,fiscal_year) ); INSERT INTO sales(sales_employee,fiscal_year,sale) VALUES('Bob',2016,100), ('Bob',2017,150), ('Bob',2018,200), ('Alice',2016,150), ('Alice',2017,100), ('Alice',2018,200), ('John',2016,200), ('John',2017,150), ('John',2018,250); SELECT * FROM sales; +----------------+-------------+--------+ | sales_employee | fiscal_year | sale | +----------------+-------------+--------+ | Alice | 2016 | 150.00 | | Alice | 2017 | 100.00 | | Alice | 2018 | 200.00 | | Bob | 2016 | 100.00 | | Bob | 2017 | 150.00 | | Bob | 2018 | 200.00 | | John | 2016 | 200.00 | | John | 2017 | 150.00 | | John | 2018 | 250.00 | +----------------+-------------+--------+ 9 rows in set (0.01 sec) 聚合函数将来自多行的数据汇总到单个结果行中。例如，以下SUM()函数返回记录年份中所有员工的总销售额： SELECT SUM(sale) FROM sales; +-----------+ | SUM(sale) | +-----------+ | 1500.00 | +-----------+ 1 row in set (0.01 sec) GROUP BY子句允许您将聚合函数应用于行的子集。例如，您可能希望按会计年度计算总销售额： SELECT fiscal_year, SUM(sale) FROM sales GROUP BY fiscal_year; +-------------+-----------+ | fiscal_year | SUM(sale) | +-------------+-----------+ | 2016 | 450.00 | | 2017 | 400.00 | | 2018 | 650.00 | +-------------+-----------+ 3 rows in set (0.01 sec) 在这两个示例中，聚合函数都会减少查询返回的行数。 与带有GROUP BY子句的聚合函数一样，窗口函数也对行的子集进行操作，但它们不会减少查询返回的行数。 例如，以下查询返回每个员工的销售额，以及按会计年度计算的员工总销售额： SELECT fiscal_year, sales_employee, sale, SUM(sale) OVER (PARTITION BY fiscal_year) total_sales FROM sales; +-------------+----------------+--------+-------------+ | fiscal_year | sales_employee | sale | total_sales | +-------------+----------------+--------+-------------+ | 2016 | Alice | 150.00 | 450.00 | | 2016 | Bob | 100.00 | 450.00 | | 2016 | John | 200.00 | 450.00 | | 2017 | Alice | 100.00 | 400.00 | | 2017 | Bob | 150.00 | 400.00 | | 2017 | John | 150.00 | 400.00 | | 2018 | Alice | 200.00 | 650.00 | | 2018 | Bob | 200.00 | 650.00 | | 2018 | John | 250.00 | 650.00 | +-------------+----------------+--------+-------------+ 9 rows in set (0.02 sec) 在此示例中，SUM()函数用作窗口函数，函数对由OVER子句内容定义的一组行进行操作。SUM()应用函数的一组行称为窗口。 SUM()窗口函数由财政年度像它与查询报告不仅总销量GROUP BY子句，而且结果中的每一行中，而不是行的总数返回。 需要注意的是窗函数的结果集毕竟进行JOIN，WHERE，GROUP BY，以及HAVING子句和前ORDER BY，LIMIT和SELECT DISTINCT。 窗口函数语法 调用窗口函数的一般语法如下： window_function_name(expression) OVER ( [partition_defintion] [order_definition] [frame_definition] ) 在这个语法中： 首先，指定窗口函数名称，后跟表达式。 其次，指定OVER具有三个可能元素的子句：分区定义，顺序定义和帧定义。 OVER子句后面的开括号和右括号是强制性的，即使没有表达式，例如： window_function_name(expression) OVER() partition_clause 句法 将partition_clause行分成块或分区。两个分区由分区边界分隔。 窗口函数在分区内执行，并在跨越分区边界时重新初始化。 partition_clause语法如下所示： PARTITION BY [{,...}] 您可以在PARTITION BY子句中指定一个或多个表达式。多个表达式用逗号分隔。 order_by_clause 句法 order_by_clause语法如下： ORDER BY [ASC|DESC], [{,...}] ORDER BY子句指定行在分区中的排序方式。可以在多个键上的分区内对数据进行排序，每个键由表达式指定。多个表达式也用逗号分隔。 与PARTITION BY子句类似ORDER BY，所有窗口函数也支持子句。但是，仅对ORDER BY顺序敏感的窗口函数使用子句才有意义。 frame_clause 句法 帧是当前分区的子集。要定义子集，请使用frame子句，如下所示： frame_unit {|} 相对于当前行定义帧，这允许帧根据其分区内当前行的位置在分区内移动。 帧单位指定当前行和帧行之间的关系类型。它可以是ROWS或RANGE。当前行和帧行的偏移量是行号，如果帧单位是ROWS行值，则行值是帧单位RANGE。 所述frame_start和frame_between定义帧边界。 将frame_start包含下列之一： UNBOUNDED PRECEDING：frame从分区的第一行开始。 N PRECEDING：第一个当前行之前的物理N行。N可以是文字数字或计算结果的表达式。 CURRENT ROW：当前计算的行 frame_between如下： BETWEEN frame_boundary_1 AND frame_boundary_2 frame_boundary_1和frame_boundary_2可各自含有下列之一： frame_start：如前所述。 UNBOUNDED FOLLOWING：框架结束于分区的最后一行。 N FOLLOWING：当前行之后的物理N行。 如果未frame_definition在OVER子句中指定，则MySQL默认使用以下帧： RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW MySQL窗口函数列表 下表显示了MySQL中的窗口函数： 名称 描述 CUME_DIST 计算一组值中值的累积分布。 DENSE_RANK 根据ORDER BY子句为其分区中的每一行分配一个排名。 它为具有相同值的行分配相同的排名。 如果两行或更多行具有相同的等级，则排序值序列中将没有间隙。 FIRST_VALUE 返回指定表达式相对于窗口框架中第一行的值。 LAG 返回分区中当前行之前的第N行的值。 如果不存在前一行，则返回NULL。 LAST_VALUE 返回指定表达式相对于窗口框架中最后一行的值。 LEAD 返回分区中当前行之后的第N行的值。 如果不存在后续行，则返回NULL。 NTH_VALUE 返回窗口框架第N行的参数值 NTILE 将每个窗口分区的行分配到指定数量的已排名组中。 PERCENT_RANK 计算分区或结果集中行的百分位数 RANK 与DENSE_RANK（）函数类似，只是当两行或更多行具有相同的排名时，排序值序列中存在间隙。 ROW_NUMBER 为其分区中的每一行分配一个连续整数 Update time： 2020-08-18 "},"MySQL/窗口函数/四大排名函数.html":{"url":"MySQL/窗口函数/四大排名函数.html","title":"四大排名函数","keywords":"","body":"四大排名函数 Sql四大排名函数(ROW_NUMBER、RANK、DENSE_RANK、NTILE) 创建数据表： CREATE TABLE rk ( ID int NOT NULL, UserId int NOT NULL, TotalPrice int NOT NULL, SubTime datetime NOT NULL ); insert into rk values (1, 1, 100, '2015-01-07 17:18:22.450'), (2, 2, 500, '2015-01-07 17:18:34.433'), (3, 3, 300, '2015-01-07 17:18:39.150'), (4, 2, 1000, '2015-01-07 17:18:43.580'), (5, 1, 520, '2015-01-07 17:18:48.277'), (6, 2, 2000, '2015-01-07 17:22:26.590'); 一、RANK rank函数用于返回结果集的分区内每行的排名， 行的排名是相关行之前的排名数加一。 简单来说 rank 函数就是对查询出来的记录进行排名，与 row_number 函数不同的是，rank 函数考虑到了over 子句中排序字段值相同的情况，如果使用rank函数来生成序号，over子句中排序字段值相同的序号是一样的，后面字段值不相同的序号将跳过相同的排名号排下一个，也就是相关行之前的排名数加一，可以理解为根据当前的记录数生成序号，后面的记录依此类推。 select *, rank() over (order by UserId) rankk from rk; 由上图可以看出，rank函数在进行排名时，同一组的序号是一样的，而后面的则是根据当前的记录数依次类推，图中第一、二条记录的用户Id相同，所以他们的序号是一样的，第三条记录的序号则是3。　 二、DENSE_RANK dense_rank函数的功能与 rank 函数类似，dense_rank 函数在生成序号时是连续的，而rank 函数生成的序号有可能不连续。dense_rank 函数出现相同排名时，将不跳过相同排名号，rank值紧接上一次的rank值。在各个分组内，rank()是跳跃排序，有两个第一名时接下来就是第四名，dense_rank()是连续排序，有两个第一名时仍然跟着第二名。 select *, dense_rank() over (order by UserId) dk from rk; 图中第一、二条记录的用户Id相同，所以他们的序号是一样的，第三条记录的序号紧接上一个的序号，所以为2不为3，后面的依此类推 三、ROW_NUMBER row_number 的用途的非常广泛，排序最好用他，一般可以用来实现web程序的分页，他会为查询出来的每一行记录生成一个序号，依次排序且不会重复，注意使用row_number 函数时必须要用over 子句选择对某一列进行排序才能生成序号。row_number用法实例: select * ,row_number() over (order by SubTime desc ) row_num from rk; 查询结果如下图所示： 图中的 row_num 列就是 row_number 函数生成的序号列，其基本原理是先使用over子句中的排序语句对记录进行排序，然后按照这个顺序生成序号。over子句中的order by子句与SQL语句中的order by子句没有任何关系，这两处的order by可以完全不同，如以下sql，over子句中根据SubTime降序排列，Sql语句中则按TotalPrice降序排列。 select * ,row_number() over (order by SubTime desc ) row_num from rk order by TotalPrice desc ; 两次执行得到的结果不同主要是语句的执行顺序问题，row_number 所对应的行的数据是一样的。 四、NTILE ntile 函数可以对序号进行分组处理，将有序分区中的行分发到指定数目的组中。 各个组有编号，编号从一开始。 对于每一个行，ntile 将返回此行所属的组的编号。这就相当于将查询出来的记录集放到指定长度的数组中，每一个数组元素存放一定数量的记录。ntile 函数为每条记录生成的序号就是这条记录所有的数组元素的索引（从1开始）。也可以将每一个分配记录的数组元素称为“桶”。ntile函数有一个参数，用来指定桶数。 select *, ntile(4) over (order by SubTime desc ) nt from rk; 表的总记录数是6条，而上面的Sql语句ntile函数指定的组数是4，那么Sql Server2005是怎么来决定每一组应该分多少条记录呢？这里我们就需要了解ntile函数的分组依据（约定）。 ntile函数的分组依据（约定） 　　1、每组的记录数不能大于它上一组的记录数，即编号小的桶放的记录数不能小于编号大的桶。 也就是说，第1组中的记录数只能大于等于第2组及以后各组中的记录数。 　　2、所有组中的记录数要么都相同，要么从某一个记录较少的组（命名为X）开始后面所有组的记录数都与该组（X组）的记录数相同。也就是说，如果有个组，前三组的记录数都是9，而第四组的记录数是8，那么第五组和第六组的记录数也必须是8。 　　这里对约定2进行详细说明一下，以便于更好的理解。 　　首先系统会去检查能不能对所有满足条件的记录进行平均分组，若能则直接平均分配就完成分组了；若不能，则会先分出一个组，这个组分多少条记录呢？就是 （总记录数/总组数）+1 条，之所以分配 （总记录数/总组数）+1 条是因为当不能进行平均分组时，总记录数%总组数肯定是有余的，又因为分组约定1，所以先分出去的组需要+1条。 　　分完之后系统会继续去比较余下的记录数和未分配的组数能不能进行平均分配，若能，则平均分配余下的记录；若不能，则再分出去一组，这个组的记录数也是（总记录数/总组数）+1条。 　　然后系统继续去比较余下的记录数和未分配的组数能不能进行平均分配，若能，则平均分配余下的记录；若还是不能，则再分配出去一组，继续比较余下的......这样一直进行下去，直至分组完成。 　　举个例子，将51条记录分配成5组，51%5==1不能平均分配，则先分出去一组（51/5）+1=11条记录，然后比较余下的 51-11=40 条记录能否平均分配给未分配的4组，能平均分配，则剩下的4组，每组各40/4=10 条记录，分配完成，分配结果为：11，10，10，10，10， 验证 select nt,count(ID) recordCount from ( select *, ntile(4) over (order by SubTime desc) nt from rk ) as t group by t.nt; 五、rank, dense_rank, row_number有什么区别呢？ 原始表： select *, rank() over (order by 成绩 desc) as ranking, dense_rank() over (order by 成绩 desc) as dese_rank, row_number() over (order by 成绩 desc) as row_num from 班级; 得到结果： 从上面的结果可以看出： 1)rank函数：这个例子中是5位，5位，5位，8位，也就是如果有并列名次的行，会占用下一名次的位置。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：1，1，1，4。 2)dense_rank函数：这个例子中是5位，5位，5位，6位，也就是如果有并列名次的行，不占用下一名次的位置。比如正常排名是1，2，3，4，但是现在前3名是并列的名次，结果是：1，1，1，2。 3)row_number函数：这个例子中是5位，6位，7位，8位，也就是不考虑并列名次的情况。比如前3名是并列的名次，排名是正常的1，2，3，4。 这三个函数的区别如下： 六、总结 在使用排名函数的时候需要注意以下三点： 　　1、排名函数必须有 OVER 子句。 　　2、排名函数必须有包含 ORDER BY 的 OVER 子句。 　　3、分组内从1开始排序。 参考 Sql 四大排名函数（ROW_NUMBER、RANK、DENSE_RANK、NTILE）简介 Update time： 2020-08-18 "},"MySQL/窗口函数/分区函数Partition By.html":{"url":"MySQL/窗口函数/分区函数Partition By.html","title":"分区函数Partition By","keywords":"","body":"分区函数Partition By partition by关键字是分析性函数的一部分，它和聚合函数不同的地方在于它能返回一个分组中的多条记录，而聚合函数一般只有一条反映统计值的记录，partition by用于给结果集分组，如果没有指定那么它把整个结果集作为一个分组，分区函数一般与排名函数一起使用。 准备测试数据： create table Student ( id int, Grade int, Score int ); insert into Student values (1,1,88), (2,1,66), (3,1,75), (4,2,30), (5,2,70), (6,2,80), (7,2,60), (8,3,90), (9,3,70), (10,3,80), (11,3,80); 一、分区函数Partition By的与row_number() 的用法 1、不分班按学生成绩排名 select *,row_number() over(order by Score desc) as Sequence from Student; -- 让数据先按班级进行分组，在每个组内进行排序 2、分班后按学生成绩排名 select *, row_number() over (partition by Grade order by Score desc ) Sequence from student; 3、获取每个班的前 2 (几)名 select * from ( select *, row_number() over ( partition by Grade order by Score desc ) Sequence from student ) T where T.Sequence T.Sequence 是排名的序号 二、分区函数Partition By 与排序 rank()的用法 1、分班后按学生成绩排名 该语句是对分数相同的记录进行了同一排名，例如：两个80分的并列第2名，第3名就没有了 select *, rank() over(partition by Grade order by Score desc) as Sequence from Student; 2、获取每个班的前2(几)名 该语句是对分数相同的记录进行了同一排名，例如：两个80分的并列第2名，第4名就没有了 select * from ( select *, rank() over (partition by Grade order by Score desc ) Sequence from student ) T where T.Sequence 参考 分区函数Partition By的与row_number()的用法以及与排序rank()的用法详解(获取分组(分区)中前几条记录 SQL中Partition关键字的使用 Update time： 2020-08-18 "},"MySQL/窗口函数/PERCENT_RANK 函数.html":{"url":"MySQL/窗口函数/PERCENT_RANK 函数.html","title":"PERCENT_RANK 函数","keywords":"","body":"PERCENT_RANK 函数 PERCENT_RANK 函数 这PERCENT_RANK()是一个窗口函数，用于计算分区或结果集中行的百分位数。 以下显示了PERCENT_RANK()函数的语法： PERCENT_RANK() OVER ( PARTITION BY expr,... ORDER BY expr [ASC|DESC],... ) PERCENT_RANK()函数返回一个从0到1的数字。 对于指定的行，PERCENT_RANK()计算行的等级减1，除以评估的分区或查询结果集中的行数减1： (rank - 1) / (total_rows - 1) 在此公式中，rank是指定行的等级，total_rows是要计算的行数。 PERCENT_RANK()对于分区或结果集中的第一行，函数始终返回零。重复的列值将接收相同的PERCENT_RANK()值。 与其他窗口函数类似，PARTITION BY子句将行分配到分区中，ORDER BY子句指定每个分区中行的逻辑顺序。PERCENT_RANK()为每个有序分区独立计算函数。 两个PARTITION BY和ORDER BY子句都是可选项。但是，它PERCENT_RANK()是一个顺序敏感函数，因此，您应始终使用ORDER BY子句。 PERCENT_RANK() 函数示例 创建一个名为新表productLineSales基础上的orders，orderDetails以及products从表中示例数据库： CREATE TABLE productLineSales SELECT productLine, YEAR(orderDate) orderYear, quantityOrdered * priceEach orderValue FROM orderDetails INNER JOIN orders USING (orderNumber) INNER JOIN products USING (productCode) GROUP BY productLine , YEAR(orderDate); productLineSales表存储销售数据的摘要，包括产品系列，订单年份和订单值。 +------------------+-----------+------------+ | productLine | orderYear | orderValue | +------------------+-----------+------------+ | Vintage Cars | 2013 | 4080.00 | | Classic Cars | 2013 | 5571.80 | | Trucks and Buses | 2013 | 3284.28 | | Trains | 2013 | 2770.95 | | Ships | 2013 | 5072.71 | | Planes | 2013 | 4825.44 | | Motorcycles | 2013 | 2440.50 | | Classic Cars | 2014 | 8124.98 | | Vintage Cars | 2014 | 2819.28 | | Trains | 2014 | 4646.88 | | Ships | 2014 | 4301.15 | | Planes | 2014 | 2857.35 | | Motorcycles | 2014 | 2598.77 | | Trucks and Buses | 2014 | 4615.64 | | Motorcycles | 2015 | 4004.88 | | Classic Cars | 2015 | 5971.35 | | Vintage Cars | 2015 | 5346.50 | | Trucks and Buses | 2015 | 6295.03 | | Trains | 2015 | 1603.20 | | Ships | 2015 | 3774.00 | | Planes | 2015 | 4018.00 | +------------------+-----------+------------+ 21 rows in set (0.02 sec) PERCENT_RANK()在查询结果集上使用 以下查询按订单值查找每个产品系列的百分位数排名： WITH t AS ( SELECT productLine, SUM(orderValue) orderValue FROM productLineSales GROUP BY productLine ) SELECT productLine, orderValue, ROUND( PERCENT_RANK() OVER ( ORDER BY orderValue ) ,2) percentile_rank FROM t; 在这个例子中： 首先，我们使用公用表表达式按产品线汇总订单值。 其次，我们用它PERCENT_RANK()来计算每种产品的订单价值的百分等级。此外，我们使用ROUND()函数将值舍入为2十进制，以获得更好的表示。 这是输出： +------------------+------------+-----------------+ | productLine | orderValue | percentile_rank | +------------------+------------+-----------------+ | Trains | 9021.03 | 0.00 | | Motorcycles | 9044.15 | 0.17 | | Planes | 11700.79 | 0.33 | | Vintage Cars | 12245.78 | 0.50 | | Ships | 13147.86 | 0.67 | | Trucks and Buses | 14194.95 | 0.83 | | Classic Cars | 19668.13 | 1.00 | +------------------+------------+-----------------+ 7 rows in set (0.01 sec) 以下是输出中的一些分析： 订单价值Trains并不比任何其他产品线更好，后者用零表示。 Vintage Cars 表现优于50％的其他产品。 Classic Cars 表现优于任何其他产品系列，因此其百分比等级为1或100％ PERCENT_RANK()在分区上使用 以下语句按年度中的订单值返回产品系列的百分位数排名： SELECT productLine, orderYear, orderValue, ROUND( PERCENT_RANK() OVER ( PARTITION BY orderYear ORDER BY orderValue ),2) percentile_rank FROM productLineSales; 这是输出： +------------------+-----------+------------+-----------------+ | productLine | orderYear | orderValue | percentile_rank | +------------------+-----------+------------+-----------------+ | Motorcycles | 2013 | 2440.50 | 0.00 | | Trains | 2013 | 2770.95 | 0.17 | | Trucks and Buses | 2013 | 3284.28 | 0.33 | | Vintage Cars | 2013 | 4080.00 | 0.50 | | Planes | 2013 | 4825.44 | 0.67 | | Ships | 2013 | 5072.71 | 0.83 | | Classic Cars | 2013 | 5571.80 | 1.00 | | Motorcycles | 2014 | 2598.77 | 0.00 | | Vintage Cars | 2014 | 2819.28 | 0.17 | | Planes | 2014 | 2857.35 | 0.33 | | Ships | 2014 | 4301.15 | 0.50 | | Trucks and Buses | 2014 | 4615.64 | 0.67 | | Trains | 2014 | 4646.88 | 0.83 | | Classic Cars | 2014 | 8124.98 | 1.00 | | Trains | 2015 | 1603.20 | 0.00 | | Ships | 2015 | 3774.00 | 0.17 | | Motorcycles | 2015 | 4004.88 | 0.33 | | Planes | 2015 | 4018.00 | 0.50 | | Vintage Cars | 2015 | 5346.50 | 0.67 | | Classic Cars | 2015 | 5971.35 | 0.83 | | Trucks and Buses | 2015 | 6295.03 | 1.00 | +------------------+-----------+------------+-----------------+ 21 rows in set (0.01 sec) Update time： 2020-08-18 "},"MySQL/窗口函数/CUME_DIST函数.html":{"url":"MySQL/窗口函数/CUME_DIST函数.html","title":"CUME_DIST函数","keywords":"","body":"CUME_DIST函数 CUME_DIST() 函数 CUME_DIST() 函数概述 CUME_DIST()是一个窗口函数，它返回一组值中值的累积分布。它表示值小于或等于行的值除以总行数的行数。 CUME_DIST()函数的返回值大于零且小于或等于1（0 CUME_DIST()CUME_DIST()值。 以下显示了CUME_DIST()函数的语法： CUME_DIST() OVER ( PARTITION BY expr, ... ORDER BY expr [ASC | DESC], ... ) 在此语法中， PARTITION BY 子句将FROM子句返回的结果集划分为CUME_DIST()函数适用的分区。 ORDER BY子句指定每个分区中行的逻辑顺序，或者在PARTITION BY省略的情况下指定整个结果集。CUME_DIST()函数根据分区中的顺序计算每行的累积分布值。 CUME_DIST()函数的近似公式如下： ROW_NUMBER() / total_rows CUME_DIST() 函数示例 让我们创建一个以scores示例的一些示例数据命名的表： CREATE TABLE scores ( name VARCHAR(20) PRIMARY KEY, score INT NOT NULL ); INSERT INTO scores(name, score) VALUES ('Smith', 81), ('Jones', 55), ('Williams', 55), ('Taylor', 62), ('Brown', 62), ('Davies', 84), ('Evans', 87), ('Wilson', 72), ('Thomas', 72), ('Johnson', 100); 查找结果集中分数的累积分布： select name, score, row_number() over (order by score) row_num, cume_dist() over (order by score) cume_dist_val from scores; 在此示例中，分数按从55到100的升序排序。请注意，ROW_NUMBER()添加了功能以供参考。 那么CUME_DIST()函数如何执行计算？ 对于第一行，函数查找结果集中的行数，其值小于或等于55.结果为2.然后，CUME_DIST()函数将2除以总行数10：2/10。结果是0.2或20％。相同的逻辑应用于第二行。 对于第三行，函数查找值小于或等于62的行数。有四行。然后CUME_DIST()函数的结果是：4/10 = 0.4，即40％。 相同的计算逻辑应用于其余行。 Update time： 2020-08-18 "},"MySQL/窗口函数/FIRST_VALUE.html":{"url":"MySQL/窗口函数/FIRST_VALUE.html","title":"FIRST_VALUE","keywords":"","body":"FIRST_VALUE FIRST_VALUE() 函数概述 FIRST_VALUE()是一个窗口函数，允许您选择窗口框架，分区或结果集的第一行。 以下说明了FIRST_VALUE()函数的语法： FIRST_VALUE(expression) OVER ( [partition_clause] [order_clause] [frame_clause] ) 表达 FIRST_VALUE()函数返回expression窗口框架第一行的值。 OVER条款由三个条款：partition_clause，order_clause，和frame_clause。 partition_clause partition_clause子句将结果集的行划分为函数独立应用的分区。partition_clause语法如下： PARTITION BY expr1, expr2, ... order_clause order_clause子句指定FIRST_VALUE()函数操作的每个分区中行的逻辑顺序。以下显示了以下语法order_clause： ORDER BY expr1 [ASC|DESC], expr2 [ASC|DESC], ... frame_clause frame_clause定义当前分区的子集（或帧） FIRST_VALUE() 函数示例 以下语句创建一个名为overtime的新表，并为演示插入示例数据： CREATE TABLE overtime ( employee_name VARCHAR(50) NOT NULL, department VARCHAR(50) NOT NULL, hours INT NOT NULL, PRIMARY KEY (employee_name , department) ); INSERT INTO overtime(employee_name, department, hours) VALUES('Diane Murphy','Accounting',37), ('Mary Patterson','Accounting',74), ('Jeff Firrelli','Accounting',40), ('William Patterson','Finance',58), ('Gerard Bondur','Finance',47), ('Anthony Bow','Finance',66), ('Leslie Jennings','IT',90), ('Leslie Thompson','IT',88), ('Julie Firrelli','Sales',81), ('Steve Patterson','Sales',29), ('Foon Yue Tseng','Sales',65), ('George Vanauf','Marketing',89), ('Loui Bondur','Marketing',49), ('Gerard Hernandez','Marketing',66), ('Pamela Castillo','SCM',96), ('Larry Bott','SCM',100), ('Barry Jones','SCM',65); 1）FIRST_VALUE()在整个查询结果集示例中使用MySQL 函数 以下语句获取员工姓名，加班时间和加班时间最少的员工： select employee_name, hours, first_value(employee_name) over ( order by hours ) least_over_time from overtime; 在此示例中，ORDER BY子句按结果集对行中的行进行了按小时排序，并FIRST_VALUE()选择了第一行，表示加班时间最短的员工。 2）FIRST_VALUE()在分区示例中使用MySQL 以下语句查找每个部门加班时间最少的员工： select employee_name, department, hours, first_value(employee_name) over ( partition by department order by hours )least_over_time from overtime; 在这个例子中： 首先，PARTITION BY条款将员工按部门划分为分区。换句话说，每个分区由属于同一部门的员工组成。 其次，ORDER BY子句指定了每个分区中的行顺序。 第三，FIRST_VALUE()按小时排序对每个分区进行操作。它返回了每个分区中的第一行，分区是部门内加班时间最少的员工。 Update time： 2020-08-18 "},"MySQL/窗口函数/LAST_VALUE.html":{"url":"MySQL/窗口函数/LAST_VALUE.html","title":"LAST_VALUE","keywords":"","body":"LAST_VALUE LAST_VALUE() 函数 LAST_VALUE()函数是一个窗口函数，允许您选择有序行集中的最后一行。 以下显示了LAST_VALUE()函数的语法： LAST_VALUE (expression) OVER ( [partition_clause] [order_clause] [frame_clause] ) LAST_VALUE()函数返回expression有序行集的最后一行的值。 OVER有三个子句：partition_clause，order_clause，和frame_clause。 partition_clause partition_clause语法如下： PARTITION BY expr1, expr2, ... PARTITION BY子句分配结果集成由一个或多个表达式指定多个分区expr1，expr2等LAST_VALUE()函数被独立地施加到每个分区。 order_clause order_clause语法如下： ORDER BY expr1 [ASC|DESC],... ORDER BY子句指定LAST_VALUE()函数运行的分区中行的逻辑顺序。 frame_clause frame_clause定义了所述当前分区的所述子集LAST_VALUE()函数应用。 LAST_VALUE() 函数示例 使用的数据仍然是上面建立的 table 1）MySQL LAST_VALUE()在整个查询结果示例中 select employee_name, hours, last_value(employee_name) over ( order by hours range between unbounded preceding and unbounded following ) highest_overtime_employee from overtime; 在此示例中，ORDER BY子句将结果集中行的逻辑顺序指定为从低到高的小时。 默认帧规范如下： RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW 这意味着框架从第一行开始，到结果集的当前行结束。 因此，为了获得加班时间最长的员工，我们将框架规格更改为以下内容： RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING 这表示框架从第一行开始，到结果集的最后一行结束。 2）MySQL LAST_VALUE()上的分区示例 以下语句查找每个部门加班时间最长的员工： select employee_name, department, hours, last_value(employee_name) over ( partition by department order by hours range between unbounded preceding and unbounded following ) most_overtime_employee from overtime; 在这个例子中，首先，PARTITION BY子句按部门划分了员工。然后，ORDER BY子句通过加班从低到高命令每个部门的员工。 在这种情况下，帧规范是整个分区。结果，LAST_VALUE()函数选择了每个分区中的最后一行，分区是加班时间最高的员工。 Update time： 2020-08-18 "},"MySQL/窗口函数/LAG、LEAD函数.html":{"url":"MySQL/窗口函数/LAG、LEAD函数.html","title":"LAG、LEAD函数","keywords":"","body":"LAG、LEAD函数 AG() 函数 LAG()函数是一个窗口函数，返回分区中当前行之前的第N行的值。 如果不存在前一行，则返回NULL。 LAG([,offset[, default_value]]) OVER ( PARTITION BY expr,... ORDER BY expr [ASC|DESC],... ) expression LAG()函数返回expression当前行之前的行的值，其值为offset 其分区或结果集中的行数。 offset offset是从当前行返回的行数，以获取值。offset必须是零或文字正整数。如果offset为零，则LAG()函数计算expression当前行的值。如果未指定offset，则LAG()默认情况下函数使用一个。 default_value 如果没有前一行，则LAG()函数返回default_value。例如，如果offset为2，则第一行的返回值为default_value。如果省略default_value，则默认LAG()返回函数NULL。 PARTITION BY 子句 PARTITION BY子句将结果集中的行划分LAG()为应用函数的分区。如果省略PARTITION BY子句，LAG()函数会将整个结果集视为单个分区。 ORDER BY 子句 ORDER BY子句指定在LAG()应用函数之前每个分区中的行的顺序。 LAG()函数可用于计算当前行和上一行之间的差异。 LAG() 函数示例 返回特定年份和上一年度中每个产品系列的订单值： WITH productline_sales AS ( SELECT productline, YEAR(orderDate) order_year, ROUND(SUM(quantityOrdered * priceEach),0) order_value FROM orders INNER JOIN orderdetails USING (orderNumber) INNER JOIN products USING (productCode) GROUP BY productline, order_year ) SELECT productline, order_year, order_value, LAG(order_value, 1) OVER ( PARTITION BY productLine ORDER BY order_year ) prev_year_order_value FROM productline_sales; 输出 +------------------+------------+-------------+-----------------------+ | productline | order_year | order_value | prev_year_order_value | +------------------+------------+-------------+-----------------------+ | Classic Cars | 2013 | 1374832 | NULL | | Classic Cars | 2014 | 1763137 | 1374832 | | Classic Cars | 2015 | 715954 | 1763137 | | Motorcycles | 2013 | 348909 | NULL | | Motorcycles | 2014 | 527244 | 348909 | | Motorcycles | 2015 | 245273 | 527244 | | Planes | 2013 | 309784 | NULL | | Planes | 2014 | 471971 | 309784 | | Planes | 2015 | 172882 | 471971 | | Ships | 2013 | 222182 | NULL | | Ships | 2014 | 337326 | 222182 | | Ships | 2015 | 104490 | 337326 | | Trains | 2013 | 65822 | NULL | | Trains | 2014 | 96286 | 65822 | | Trains | 2015 | 26425 | 96286 | | Trucks and Buses | 2013 | 376657 | NULL | | Trucks and Buses | 2014 | 465390 | 376657 | | Trucks and Buses | 2015 | 182066 | 465390 | | Vintage Cars | 2013 | 619161 | NULL | | Vintage Cars | 2014 | 854552 | 619161 | | Vintage Cars | 2015 | 323846 | 854552 | +------------------+------------+-------------+-----------------------+ 21 rows in set (0.04 sec) LEAD 函数 LEAD() 函数概述 LEAD()函数是一个窗口函数，返回分区中当前行之后的第N行的值。 如果不存在后续行，则返回NULL。 与LAG()函数类似，LEAD()函数对于计算同一结果集中当前行和后续行之间的差异非常有用。 LEAD([,offset[, default_value]]) OVER ( PARTITION BY (expr) ORDER BY (expr) ) expression LEAD()函数返回的值expression从offset-th有序分区排。 offset offset是从当前行向前行的行数，以获取值。 offset必须是一个非负整数。如果offset为零，则LEAD()函数计算expression当前行的值。 如果省略 offset，则LEAD()函数默认使用一个。 default_value 如果没有后续行，则LEAD()函数返回default_value。例如，如果offset是1，则最后一行的返回值为default_value。 如果您未指定default_value，则函数返回 NULL 。 PARTITION BY 子句 PARTITION BY子句将结果集中的行划分LEAD()为应用函数的分区。 如果PARTITION BY未指定子句，则结果集中的所有行都将被视为单个分区。 ORDER BY子句 ORDER BY子句确定LEAD()应用函数之前分区中行的顺序。 LEAD() 函数示例 查找每个客户的订单日期和下一个订单日期： SELECT customerName, orderDate, LEAD(orderDate,1) OVER ( PARTITION BY customerNumber ORDER BY orderDate ) nextOrderDate FROM orders INNER JOIN customers USING (customerNumber); 输出： +------------------------------------+------------+---------------+ | customerName | orderDate | nextOrderDate | +------------------------------------+------------+---------------+ | Atelier graphique | 2013-05-20 | 2014-09-27 | | Atelier graphique | 2014-09-27 | 2014-11-25 | | Atelier graphique | 2014-11-25 | NULL | | Signal Gift Stores | 2013-05-21 | 2014-08-06 | | Signal Gift Stores | 2014-08-06 | 2014-11-29 | | Signal Gift Stores | 2014-11-29 | NULL | | Australian Collectors, Co. | 2013-04-29 | 2013-05-21 | | Australian Collectors, Co. | 2013-05-21 | 2014-02-20 | | Australian Collectors, Co. | 2014-02-20 | 2014-11-24 | | Australian Collectors, Co. | 2014-11-24 | 2014-11-29 | | Australian Collectors, Co. | 2014-11-29 | NULL | | La Rochelle Gifts | 2014-07-23 | 2014-10-29 | | La Rochelle Gifts | 2014-10-29 | 2015-02-03 | | La Rochelle Gifts | 2015-02-03 | 2015-05-31 | | La Rochelle Gifts | 2015-05-31 | NULL | | Baane Mini Imports | 2013-01-29 | 2013-10-10 | | Baane Mini Imports | 2013-10-10 | 2014-10-15 | ... 参考 MySQL LEAD 函数 MySQL LAG() 函数 Update time： 2020-09-08 "},"MySQL/窗口函数/NTH_VALUE函数.html":{"url":"MySQL/窗口函数/NTH_VALUE函数.html","title":"NTH_VALUE函数","keywords":"","body":"NTH_VALUE函数 NTH_VALUE 函数 这NTH_VALUE()是一个窗口函数，允许您从有序行集中的第N行获取值。 以下显示了NTH_VALUE()函数的语法： NTH_VALUE(expression, N) FROM FIRST OVER ( partition_clause order_clause frame_clause ) NTH_VALUE()函数返回expression窗口框架第N行的值。如果第N行不存在，则函数返回NULL。N必须是正整数，例如1,2和3。 FROM FIRST指示NTH_VALUE()功能在窗口帧的第一行开始计算。 请注意，SQL标准支持FROM FIRST和FROM LAST。但是，MySQL只支持FROM FIRST。如果要模拟效果FROM LAST，则可以使用其中ORDER BY的over_clause相反顺序对结果集进行排序。 NTH_VALUE() 函数示例 创建一个以basic_pay演示命名的新表。 CREATE TABLE basic_pays ( employee_name VARCHAR(50) NOT NULL, department VARCHAR(50) NOT NULL, salary INT NOT NULL, PRIMARY KEY (employee_name, department) ); INSERT INTO basic_pays(employee_name, department, salary) VALUES ('Diane Murphy', 'Accounting', 8435), ('Mary Patterson', 'Accounting', 9998), ('Jeff Firrelli', 'Accounting', 8992), ('William Patterson', 'Accounting', 8870), ('Gerard Bondur', 'Accounting', 11472), ('Anthony Bow', 'Accounting', 6627), ('Leslie Jennings', 'IT', 8113), ('Leslie Thompson', 'IT', 5186), ('Julie Firrelli', 'Sales', 9181), ('Steve Patterson', 'Sales', 9441), ('Foon Yue Tseng', 'Sales', 6660), ('George Vanauf', 'Sales', 10563), ('Loui Bondur', 'SCM', 10449), ('Gerard Hernandez', 'SCM', 6949), ('Pamela Castillo', 'SCM', 11303), ('Larry Bott', 'SCM', 11798), ('Barry Jones', 'SCM', 10586); NTH_VALUE()函数在结果集上 以下语句使用NTH_VALUE()函数查找薪水第二高的员工： select employee_name, salary, nth_value(employee_name, 2) over ( order by salary desc ) second_highest_salary from basic_pays; NTH_VALUE() 函数分区示例 以下查询查找每个部门中薪水第二高的员工： select employee_name, department, salary, nth_value(employee_name, 2) over ( partition by department order by salary desc range between unbounded preceding and unbounded following ) second_highest_salary from basic_pays; Update time： 2020-08-18 "},"MySQL/窗口函数/聚合函数作为窗口函数.html":{"url":"MySQL/窗口函数/聚合函数作为窗口函数.html","title":"聚合函数作为窗口函数","keywords":"","body":"聚合函数作为窗口函数 用途：在窗口中每条记录动态地应用聚合函数（SUM()、AVG()、MAX()、MIN()、COUNT()），可以动态计算在指定的窗口内的各种聚合函数值 作用：聚合函数作为窗口函数，是起到\"累加/累计\"的效果，比如，就是截止到本行，最大值？最小值是多少 与专用窗口函数的区别：括号中需要有指定列，不能为空 专用窗口函数---rank(),dense_rank(),row_number()（括号中没有参数，注意区分三者区别） 聚合函数---max(),min(),sum(),avg(),count() (括号中有参数） 案例 #查找单科成绩高于该科目平均成绩的学生名单 法一解题思路： 单科成绩，表示需要按科目进行分组，分组有两种：group by子句和窗口函数的partition by； 要求平均值，需要通过avg()实现，并且找到大于平均值的学生，那么不能减少行数，则用partition by； 步骤： 聚合函数作为窗口函数 与平均值比较 注意 这里不能用where 成绩>分组平均值，因为where子句在select子句之后执行 ?????????????????????? 正确语句是套用子查询： Update time： 2020-09-09 "},"MySQL/函数/函数.html":{"url":"MySQL/函数/函数.html","title":"函数","keywords":"","body":"函数 最常用的MySQL函数，包括聚合函数，字符串函数，日期时间函数，控制流函数等。 MySQL聚合函数 AVG - 计算一组值或表达式的平均值。 COUNT - 计算表中的行数。 INSTR - 返回字符串中第一次出现的子字符串的位置。 SUM - 计算一组值或表达式的总和。 MIN - 在一组值中找到最小值 MAX - 在一组值中找到最大值 MySQL字符串函数 CONCAT - 将两个或多个字符串组合成一个字符串。 LENGTH＆CHAR_LENGTH - 获取字符串的长度，以字节和字符为单位。 LEFT - 获取具有指定长度的字符串的左侧部分。 REPLACE - 搜索并替换字符串中的子字符串。 SUBSTRING - 从具有特定长度的位置开始提取子字符串。 TRIM - 从字符串中删除不需要的字符。 FIND_IN_SET - 在以逗号分隔的字符串列表中查找字符串。 FORMAT - 格式化具有特定区域设置的数字，四舍五入到小数位数 MySQL控制流功能 CASE - THEN如果WHEN满足分支中的条件，则返回分支中的相应结果，否则返回ELSE分支中的结果。 IF - 根据给定条件返回值。 IFNULL - 如果它不是NULL则返回第一个参数，否则返回第二个参数。 NULLIF - 如果第一个参数等于第二个参数，则返回NULL，否则返回第一个参数。 MySQL日期和时间函数 CURDATE - 返回当前日期。 DATEDIFF - 计算两个DATE值之间的天数 。 DAY - 获取指定日期的月份日期。 DATE_ADD - 将日期值添加到日期值。 DATE_SUB - 从日期值中减去时间值。 DATE_FORMAT - 根据指定的日期格式格式化日期值。 DAYNAME - 获取指定日期的工作日名称。 DAYOFWEEK - 返回日期的工作日索引。 EXTRACT - 提取日期的一部分。 NOW - 返回执行语句的当前日期和时间。 MONTH - 返回表示指定日期月份的整数。 STR_TO_DATE - 根据指定的格式将字符串转换为日期和时间值。 SYSDATE - 返回当前日期。 TIMEDIFF - 计算两个TIME或DATETIME值之间的差异。 TIMESTAMPDIFF - 计算两个DATE或DATETIME值之间的差异。 WEEK - 返回一个星期的日期。 WEEKDAY - 返回日期的工作日索引。 YEAR -返回日期值的年份部分。 MySQL比较功能 COALESCE - 返回第一个非null参数，这对于替换null非常方便。 GREATEST＆LEAST - 取n个参数并分别返回n个参数的最大值和最小值。 ISNULL - 如果参数为null，则返回1，否则返回零。 MySQL数学函数 ABS - 返回数字的绝对值。 CEIL - 返回大于或等于输入数字的最小整数值。 FLOOR - 返回不大于参数的最大整数值。 MOD - 返回数字的余数除以另一个。 ROUND - 将数字四舍五入到指定的小数位数。 TRUNCATE - 将数字截断为指定的小数位数。 其他MySQL功能 LAST_INSERT_ID - 获取最后生成的最后一个插入记录的序列号。 CAST - 将任何类型的值转换为具有指定类型的值。 更多 MySQL 函数 请查看访问：MySQL 函数 Update time： 2020-08-18 "},"MySQL/函数/日期函数.html":{"url":"MySQL/函数/日期函数.html","title":"日期函数","keywords":"","body":"日期函数 NOW() 函数 定义和用法 NOW() 返回当前的日期和时间。 语法 NOW() 实例 下面是 SELECT 语句： SELECT NOW(),CURDATE(),CURTIME() 结果如下所示： NOW() CURDATE() CURTIME() 2008-11-11 12:45:34 2008-11-11 12:45:34 实例 下面的 SQL 创建带有日期时间列（OrderDate）的 \"Orders\" 表： CREATE TABLE Orders ( OrderId int NOT NULL, ProductName varchar(50) NOT NULL, OrderDate datetime NOT NULL DEFAULT NOW(), PRIMARY KEY (OrderId) ) 请注意，OrderDate 列规定NOW()作为默认值。作为结果，当您向表中插入行时，当前日期和时间自动插入列中。 现在，我们想要在 \"Orders\" 表中插入一条记录： INSERT INTO Orders (ProductName) VALUES ('Jarlsberg Cheese') \"Orders\" 表将如下所示： OrderId ProductName OrderDate 1 Jarlsberg Cheese 2008-11-11 13:23:44.657 CURDATE() 函数 定义和用法 CURDATE() 返回当前的日期。 语法 CURDATE() 实例 下面是 SELECT 语句： SELECT NOW(),CURDATE(),CURTIME() 结果如下所示： NOW() CURDATE() CURTIME() 2008-11-11 12:45:34 2008-11-11 12:45:34 实例 下面的 SQL 创建带有日期时间列（OrderDate）的 \"Orders\" 表： CREATE TABLE Orders ( OrderId int NOT NULL, ProductName varchar(50) NOT NULL, OrderDate datetime NOT NULL DEFAULT CURDATE(), PRIMARY KEY (OrderId) ) 请注意，OrderDate 列规定 CURDATE() 作为默认值。作为结果，当您向表中插入行时，当前日期和时间自动插入列中。 现在，我们想要在 \"Orders\" 表中插入一条记录： INSERT INTO Orders (ProductName) VALUES ('Jarlsberg Cheese') \"Orders\" 表将如下所示： OrderId ProductName OrderDate 1 Jarlsberg Cheese 2008-11-11 CURTIME() 函数 定义和用法 CURTIME()返回当前的时间。 语法 CURTIME() 实例 下面是 SELECT 语句： SELECT NOW(),CURDATE(),CURTIME() 结果如下所示： NOW() CURDATE() CURTIME() 2008-11-11 12:45:34 2008-11-11 12:45:34 DATE_ADD() 函数 定义和用法 DATE_ADD()函数向日期添加指定的时间间隔。 语法 DATE_ADD(date,INTERVAL expr type) date 参数是合法的日期表达式。expr 参数是您希望添加的时间间隔。 type 参数: 日期类型 实例 假设我们有如下的 \"Orders\" 表： OrderId ProductName OrderDate 1 Jarlsberg Cheese 2008-11-11 13:23:44.657 现在，我们想要向 \"OrderDate\" 添加 45 天，这样就可以找到付款日期。 我们使用下面的 SELECT 语句： SELECT OrderId,DATE_ADD(OrderDate,INTERVAL 45 DAY) AS OrderPayDate FROM Orders 结果： OrderId OrderPayDate 1 2008-12-26 13:23:44.657 DATE_SUB() 函数 定义和用法 DATE_SUB() 函数从日期减去指定的时间间隔。 语法 DATE_SUB(date,INTERVAL expr type) date 参数是合法的日期表达式。expr 参数是您希望添加的时间间隔。 type 参数: 日期类型 实例 假设我们有如下的 \"Orders\" 表： OrderId ProductName OrderDate 1 Jarlsberg Cheese 2008-11-11 13:23:44.657 现在，我们想要向 \"OrderDate\" 减去 5 天。 我们使用下面的 SELECT 语句： SELECT OrderId,DATE_SUB(OrderDate,INTERVAL 5 DAY) AS SubtractDate FROM Orders 结果： OrderId SubtractDate 1 2008-11-06 13:23:44.657 DATEDIFF() 函数 定义和用法 DATEDIFF() 函数返回两个日期之间的天数。 语法 DATEDIFF(date1,date2) date1 和 date2 参数是合法的日期或日期/时间表达式。 注释：只有值的日期部分参与计算。 实例 下面是 SELECT 语句： SELECT DATEDIFF('2008-11-30','2008-11-29') AS DiffDate 结果如下所示： DiffDate 1 实例 下面是 SELECT 语句： SELECT DATEDIFF('2008-11-29','2008-11-30') AS DiffDate 结果如下所示： DiffDate -1 DATE_FORMAT() 函数 定义和用法 DATE_FORMAT()函数用于以不同的格式显示日期/时间数据。 语法 DATE_FORMAT(date,format) date 参数是合法的日期。format 规定日期/时间的输出格式。 实例 下面的脚本使用 DATE_FORMAT() 函数来显示不同的格式。我们使用 NOW() 来获得当前的日期/时间： select DATE_FORMAT(NOW(),'%b %d %Y %h:%i %p'), DATE_FORMAT(NOW(),'%m-%d-%Y'), DATE_FORMAT(NOW(),'%d %b %y'), DATE_FORMAT(NOW(),'%d %b %Y %T:%f') 结果如下所示： Nov 04 2008 11:45 PM 11-04-2008 04 Nov 08 04 Nov 2008 11:45:34:243 day()函数 DAY函数返回给定日期的月份的日期部分。下面显示DAY函数的语法： DAY(date); DAY函数接受一个参数，它是您要获取月份日期的日期值。如果date参数为零，例如'0000-00-00'，则DAY函数返回0，如果日期为NULL，则DAY函数返回NULL值。 DAY函数示例 以下示例返回2018-01-15的当天的日期： mysql> SELECT DAY('2018-01-15'); +-------------------+ | DAY('2018-01-15') | +-------------------+ | 15 | +-------------------+ 1 row in set 要根据指定的日期获取一个月中的天数，您可以组合LAST_DAY和DAY函数，如以下示例所示： mysql> SELECT DAY(LAST_DAY('2018-02-03')); +-----------------------------+ | DAY(LAST_DAY('2018-02-03')) | +-----------------------------+ | 28 | +-----------------------------+ 1 row in set LAST_DAY函数返回一月的最后一天，例如2016-02-29，DAY函数返回最后一天的那个月的日期，也就是该月份的天数。 DATE() 函数 定义和用法 DATE() 函数提取日期或日期/时间表达式的日期部分。 语法 DATE(date) date 参数是合法的日期表达式。 实例 假设我们有如下的 \"Orders\" 表： OrderId ProductName OrderDate 1 Jarlsberg Cheese 2008-11-11 13:23:44.657 下面是 SELECT 语句： SELECT ProductName, DATE(OrderDate) AS OrderDate FROM Orders WHERE OrderId=1 结果如下所示： ProductName OrderDate Jarlsberg Cheese 2008-11-11 EXTRACT() 函数 定义和用法 EXTRACT() 函数用于返回日期/时间的单独部分，比如年、月、日、小时、分钟等等。 语法 EXTRACT(unit FROM date) date 参数是合法的日期表达式。unit 参数见最后。 实例 假设我们有如下的 \"Orders\" 表： OrderId ProductName OrderDate 1 Jarlsberg Cheese 2008-11-11 13:23:44.657 下面是 SELECT 语句： SELECT EXTRACT(YEAR FROM OrderDate) AS OrderYear, EXTRACT(MONTH FROM OrderDate) AS OrderMonth, EXTRACT(DAY FROM OrderDate) AS OrderDay, FROM Orders WHERE OrderId=1 结果如下所示： OrderYear OrderMonth OrderDay 2008 11 11 format 规定日期/时间的输出格式。 格式 描述 %a 缩写星期名 %b 缩写月名 %c 月，数值 %D 带有英文前缀的月中的天 %d 月的天，数值(00-31) %e 月的天，数值(0-31) %f 微秒 %H 小时 (00-23) %I 小时 (01-12) %M 月名 %m 月，数值(00-12) %p AM 或 PM %r 时间，12-小时（hh:mm:ss AM 或 PM） %S 秒(00-59) %s 秒(00-59) %T 时间, 24-小时 (hh:mm:ss) %U 周 (00-53) 星期日是一周的第一天 %u 周 (00-53) 星期一是一周的第一天 %V 周 (01-53) 星期日是一周的第一天，与 %X 使用 %v 周 (01-53) 星期一是一周的第一天，与 %x 使用 %W 星期名 %w 周的天 （0=星期日, 6=星期六） %X 年，其中的星期日是周的第一天，4 位，与 %V 使用 %x 年，其中的星期一是周的第一天，4 位，与 %v 使用 %Y 年，4 位 %y 年，2 位 type 参数可以是下列值： Type 值 MICROSECOND SECOND MINUTE HOUR DAY WEEK MONTH QUARTER YEAR SECOND_MICROSECOND MINUTE_MICROSECOND MINUTE_SECOND HOUR_MICROSECOND HOUR_SECOND HOUR_MINUTE DAY_MICROSECOND DAY_SECOND DAY_MINUTE DAY_HOUR YEAR_MONTH unit 参数 Unit 值 MICROSECOND SECOND MINUTE HOUR DAY WEEK MONTH QUARTER YEAR SECOND_MICROSECOND MINUTE_MICROSECOND MINUTE_SECOND HOUR_MICROSECOND HOUR_SECOND HOUR_MINUTE DAY_MICROSECOND DAY_SECOND DAY_MINUTE DAY_HOUR YEAR_MONTH 参考 MySQL 日期与时间方面的函数 Update time： 2020-09-04 "},"MySQL/函数/日期函数timediff.html":{"url":"MySQL/函数/日期函数timediff.html","title":"日期函数timediff","keywords":"","body":"日期函数timediff TIMEDIFF函数介绍 TIMEDIFF返回两个TIME或DATETIME值之间的差值。 请参阅TIMEDIFF函数的以下语法。 TIMEDIFF(dt1, dt2); TIMEDIFF函数接受两个必须为相同类型的参数，即TIME或DATETIME。 TIMEDIFF函数返回表示为时间值的dt1 - dt2的结果。 因为TIMEDIFF函数返回TIME值，所以其结果被限制在从-838:59:59到838:59:59的TIME值范围内。 请注意，TIMEDIFF函数接受TIME或DATETIME类型的值。要比较两个DATE或DATETIME值之间的差异，可以使用DATEDIFF函数。 TIMEDIFF函数示例 让我们举一个例子来计算两个时间值之间的差异。 mysql> SELECT TIMEDIFF('12:00:00','10:00:00') diff; +----------+ | diff | +----------+ | 02:00:00 | +----------+ 1 row in set SQL 在这个例子中，我们计算了12:00:00和10:00:00之间的差值为：02:00:00。 以下示例计算两个DATETIME值之间的差异值： mysql> SELECT TIMEDIFF('2010-01-01 01:00:00', '2010-01-02 01:00:00') diff; +-----------+ | diff | +-----------+ | -24:00:00 | +-----------+ 1 row in set SQL 如果任一参数为NULL，TIMEDIFF函数将返回NULL。 mysql> SELECT TIMEDIFF('2010-01-01',NULL) diff; +------+ | diff | +------+ | NULL | +------+ 1 row in set, 1 warning (0.00 sec) SQL 如果传递两个不同类型的参数，一个是DATETIME，另一个是TIME，TIMEDIFF函数也返回NULL。 mysql> SELECT TIMEDIFF('2010-01-01 10:00:00','10:00:00') diff; +------+ | diff | +------+ | NULL | +------+ 1 row in set SQL TIMEDIFF函数和截断的不正确的时间值 请考虑以下示例： mysql> SELECT TIMEDIFF('2009-03-01 00:00:00', '2009-01-01 00:00:00') diff; +-----------+ | diff | +-----------+ | 838:59:59 | +-----------+ 1 row in set, 1 warning (0.00 sec) SQL 可以看到，有一个警告。下面来看看看使用SHOW WARNINGS语句是什么。 mysql> SHOW WARNINGS; +---------+------+----------------------------------------------+ | Level | Code | Message | +---------+------+----------------------------------------------+ | Warning | 1292 | Truncated incorrect time value: '1416:00:00' | +---------+------+----------------------------------------------+ 1 row in set SQL 所以结果应该是1416小时，但是如前所述，TIMEDIFF函数的结果是一个TIME值，范围是从-838:59:59到838:59:59。 因此，MySQL会截断结果。 要解决此问题，您需要使用TIMESTAMPDIFF函数，如下所示： mysql> SELECT TIMESTAMPDIFF(HOUR, '2018-01-01 00:00:00', '2018-03-01 00:00:00') diff; +------+ | diff | +------+ | 1416 | +------+ 1 row in set Update time： 2020-09-04 "},"MySQL/函数/日期函数timestampdiff.html":{"url":"MySQL/函数/日期函数timestampdiff.html","title":"日期函数timestampdiff","keywords":"","body":"日期函数timestampdiff TIMESTAMPDIFF函数的语法。 TIMESTAMPDIFF(unit,begin,end); TIMESTAMPDIFF函数返回begin-end的结果，其中begin和end是DATE或DATETIME表达式。 TIMESTAMPDIFF函数允许其参数具有混合类型，例如，begin是DATE值，end可以是DATETIME值。 如果使用DATE值，则TIMESTAMPDIFF函数将其视为时间部分为“00:00:00”的DATETIME值。 unit参数是确定(end-begin)的结果的单位，表示为整数。 以下是有效单位： MICROSECOND SECOND MINUTE HOUR DAY WEEK MONTH QUARTER YEAR TIMESTAMPDIFF函数示例 以下示例将以月份值的形式返回2018-01-01和2018-06-01的差值： mysql> SELECT TIMESTAMPDIFF(MONTH, '2018-01-01', '2018-06-01') result; +--------+ | result | +--------+ | 5 | +--------+ 1 row in set 如果您希望看到差值，只需要将unit参数从MONTH更改为DAY，如下所示： mysql> SELECT TIMESTAMPDIFF(DAY, '2010-01-01', '2010-06-01') result; +--------+ | result | +--------+ | 151 | +--------+ 1 row in set 以下语句返回两个DATETIME值(以分钟为单位)的差异值： mysql> SELECT TIMESTAMPDIFF(MINUTE, '2018-01-01 10:00:00', '2018-01-01 10:45:00') result; +--------+ | result | +--------+ | 45 | +--------+ 1 row in set TIMESTAMPDIFF函数计算年龄 CREATE TABLE persons ( id INT AUTO_INCREMENT PRIMARY KEY, full_name VARCHAR(255) NOT NULL, date_of_birth DATE NOT NULL ); INSERT INTO persons(full_name, date_of_birth) VALUES ('John Doe', '1990-01-01'), ('David Taylor', '1989-06-06'), ('Peter Drucker', '1985-03-02'), ('Lily Minsu', '1992-05-05'), ('Mary William', '1995-12-01'); 使用TIMESTAMPDIFF来计算persons表中每个人的年龄： select full_name, date_of_birth, timestampdiff(YEAR,date_of_birth,now()) 年龄 from persons; 我们计算到今天的年龄，所以今天对应的就是 end; 开始时间和结束时间的顺序不同，可能会产生负值； select full_name, date_of_birth, timestampdiff(YEAR,now(),date_of_birth) 年龄 from persons; Update time： 2020-09-04 "},"MySQL/函数/条件表达式.html":{"url":"MySQL/函数/条件表达式.html","title":"条件表达式","keywords":"","body":"条件表达式 SQL 中的条件表达式 SQL 是一种声明性的语言，它没有提供其他编程语言中的条件语句（if-then-else 或者 switch）。但是，SQL 支持 CASE表达式，可以基于一个条件列表返回不同的结果值，它更像是一种支持嵌套的三元表达式（? :）。 CASE 表达式支持两种形式：简单 CASE 表达式和搜索 CASE 表达式。另外，还存在一些简写形式的 CASE 函数，以及不同数据库产品特有的扩展。 简单 CASE 表达式 简单 CASE 表达式的语法如下： CASE expression WHEN expression_1 THEN result_1 WHEN expression_2 THEN result_2 ... [ELSE default_result] END 简单 CASE 表达式比较CASE后的表达式与WHEN列表中的表达式的值，找到第一个匹配的值（=），返回后面相应的结果；如果没有匹配值，返回ELSE子句的值；如果此时没有指定ELSE子句，返回空值。 示例 SELECT e.first_name, e.last_name, e.job_id, CASE e.job_id WHEN 'AD_PRES' THEN 'President' WHEN 'AD_VP' THEN 'Administration Vice President' WHEN 'IT_PROG' THEN 'Programmer' ELSE 'Other job' END FROM employees e; 简单 CASE 表达式仅仅比较两个值是否相等，然后返回相应的值。如果我们想要基于更加复杂的条件进行判断，例如某个值是否为空，某个值是否大于指定的数值，甚至使用子查询的结果进行判断，都需要使用更加强大的搜索 CASE 表达式。 搜索 CASE 表达式 搜索 CASE 表达式的语法如下： CASE WHEN condition_1 THEN result_1 WHEN condition_2 THEN result_1 ... [ELSE default_result] END 表达式按照顺序计算WHEN子句中的条件，找到第一个结果为 True 的分支，返回相应的结果；如果没有任何条件为真，返回ELSE中的默认值；如果此时没有指定ELSE子句，返回空值。 SELECT e.first_name, e.last_name, e.salary, CASE WHEN e.salary CASE 表达式除了可以用于SELECT列表，也可以出现在其他 SQL 子句中，例如WHERE条件、GROUP BY分组、ORDER BY排序等。 SELECT CASE WHEN e.salary NULLIF () 除了以上两种形式的 CASE 表达式之外，SQL 还定义了两个与 NULL 值相关的缩写 CASE 表达式（函数）：nullif和 coalesce。 NULLIF函数需要2个参数，如果第一个参数等于第二个参数，返回 NULL 值；否则，返回第一个参数的值： NULLIF(expression_1, expression_2) 它的等价 CASE 表达式如下： CASE WHEN expression_1 = expression_2 THEN NULL ELSE expression_1 END NULLIF 函数的一个常见用途是防止除零错误： value1 / NULLIF(value2 , 0) COALESCE 函数接受一个参数列表，并且返回第一个非空的参数值；如果所有参数都为空，返回空值： COALESCE(expression_1, expression_2, expression_3, ...) 它的等价 CASE 表达式如下： CASE WHEN expression_1 IS NOT NULL THEN expression_1 WHEN expression_2 IS NOT NULL THEN expression_2 WHEN expression_3 IS NOT NULL THEN expression_3 ... END 示例： SELECT e.first_name, e.last_name, COALESCE(e.commission_pct, 0) FROM employees e; 如果员工存在佣金百分比，返回该值；否则，显示为 0。 IF 函数 MySQL 提供了 IF 函数： IF(expr1, expr2, expr3) 它接受三个参数。如果第一个参数为真（expr1 <> 0 并且 expr1 不为空），返回第二个参数的值；否则，返回第三个参数的值。 -- For MySQL only SELECT IF(1=2'), IF(NULL, 'Y', 'N'); -- result is: 1 IFNULL(expr1, expr2)函数。它接受两个参数，如果 expr1 不为空，返回 expr1 的值；否则，返回 expr2 的值。 SELECT e.first_name, e.last_name, IFNULL(e.commission_pct, 0) FROM employees e; IFNULL函数 IFNULL函数：判断是否为空 MySQL IFNULL函数是 MySQL 控制流函数之一，它接受两个参数，如果不是 NULL，则返回第一个参数。 否则，IFNULL 函数返回第二个参数。两个参数可以是文字值或表达式。 函数的语法： IFNULL(v1,v2); 其中：如果 v1 不为 NULL，则IFNULL 函数返回 v1; 否则返回 v2 的结果。 参考： https://www.cnblogs.com/xiaohuochai/p/6081482.html Update time： 2020-08-18 "},"MySQL/函数/聚合函数.html":{"url":"MySQL/函数/聚合函数.html","title":"聚合函数","keywords":"","body":"聚合函数 AVG() 函数 返回“Products”表中“Price”列的平均值： SELECT AVG(Price) AS AveragePrice FROM Products; 定义和用法 AVG()函数返回表达式的平均值。 注意：忽略NULL值。 语法 AVG(expression) 参数值 COUNT() 函数 返回“Products”表中的产品数量： SELECT COUNT(ProductID) AS NumberOfProducts FROM Products; 定义和用法 COUNT()函数返回 select查询返回的记录数。 注意：不计算 NULL值。 语法 COUNT(expression) 参数值 1、count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL。 2、count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL。 3、count(列名) 只包括列名那一列，在统计结果的时候，会忽略列值为空。 SUM() 函数 返回“OrderDetails”表中“Quantity”字段的总和： SELECT SUM(Quantity) AS TotalItemsOrdered FROM OrderDetails; 定义和用法 SUM()函数计算一组值的总和。 注意：忽略NULL值。 语法 SUM(expression) 参数值 MIN() 函数 实例 在“Products”表格中找到最便宜产品的价格： SELECT MIN(Price) AS SmallestPrice FROM Products; 定义和用法 MIN()函数返回一组值中的最小值。 注意：请参见MAX()函数。 语法 MIN(expression) 参数值 MAX() 函数 实例 在“Products”表格中找到最昂贵产品的价格： SELECT MAX(Price) AS LargestPrice FROM Products; 定义和用法 MAX()函数返回一组值中的最大值。 注意：请参见MIN()函数。 语法 MAX(*expression*) Update time： 2020-08-18 "},"MySQL/函数/case when 与 max等聚合函数联合使用.html":{"url":"MySQL/函数/case when 与 max等聚合函数联合使用.html","title":"case when 与 max等聚合函数联合使用","keywords":"","body":"case when 与 max等聚合函数联合使用 MySQL case when 实现行转列时为什么要用 max() 或者其他聚合函数 创建表 create table tb( 姓名 varchar(10), 课程 varchar(3), 分数 int(3) ); insert into tb values ('张三','语文', 74), ('张三','数学', 83), ('张三','物理', 93), ('李四','语文', 74), ('李四','数学', 84), ('李四','物理', 94); 想要显示的结果是 ：姓名 语文 数学 物理 这种形式的（就是行转列） sql 语句1： SELECT `姓名`, (CASE `课程` WHEN '语文' THEN `分数` ELSE 0 END) '语文', (CASE `课程` WHEN '数学' THEN `分数` ELSE 0 END) '数学', (CASE `课程` WHEN '物理' THEN `分数` ELSE 0 END) '物理' FROM TB GROUP BY `姓名`; 这个结果是不对的 sql 语句2： SELECT `姓名`, MAX(CASE `课程` WHEN '语文' THEN `分数` ELSE 0 END) '语文', MAX(CASE `课程` WHEN '数学' THEN `分数` ELSE 0 END) '数学', MAX(CASE `课程` WHEN '物理' THEN `分数` ELSE 0 END) '物理' FROM TB GROUP BY `姓名`; 解析： 第一种 不加 max的时候 那么在不分组之前 SQL 为： SELECT `姓名`, CASE `课程` WHEN '语文' THEN `分数` ELSE 0 END '语文', CASE `课程` WHEN '数学' THEN `分数` ELSE 0 END '数学', CASE `课程` WHEN '物理' THEN `分数` ELSE 0 END '物理' FROM TB; 然后 group by 姓名; 执行 group by 姓名 时因为没有任何聚合函数， 那么会从基表里取group by后字段的第一条数据。即： 也就是第一条 SQL 执行的结果： 第二个 SQL。 分解下 SQL，执行MAX内CASE WHEN 及未GROUP BY 姓名时SQL： SELECT `姓名`, CASE `课程` WHEN '语文' THEN `分数` ELSE 0 END '语文', CASE `课程` WHEN '数学' THEN `分数` ELSE 0 END '数学', CASE `课程` WHEN '物理' THEN `分数` ELSE 0 END '物理' FROM TB; 这个结果其实和第一个 SQL一样。 完整的第二个 SQL： SELECT `姓名`, MAX(CASE `课程` WHEN '语文' THEN `分数` ELSE 0 END) '语文', MAX(CASE `课程` WHEN '数学' THEN `分数` ELSE 0 END) '数学', MAX(CASE `课程` WHEN '物理' THEN `分数` ELSE 0 END) '物理' FROM TB GROUP BY `姓名`; 第二个 SQL 对分数进行了MAX函数操作同时又对姓名进行了分组。() 那么这个基表max()中因为case when 课程 取最大分数，再对姓名进行分组。 自然是取了每个姓名下每个学科的最高成绩。即： 自己的理解： 和 sql 语句的执行顺序有关，先执行 group by 将数据按姓名进行分组，之后对每个分组内的数据执行聚合函数 max 参考 问答>mysql中的case when语句查询结果问题 Update time： 2020-08-18 "},"MySQL/函数/数学函数.html":{"url":"MySQL/函数/数学函数.html","title":"数学函数","keywords":"","body":"数学函数 ABS() 函数 实例 返回数字的绝对值： SELECT ABS(-243.5); 定义和用法 ABS() 函数返回数字的绝对（正）值。 语法 ABS(number) CEIL() 函数 实例 返回大于或等于25.75的最小整数值： SELECT CEIL(25.75); 定义和用法 CEIL()函数返回大于或等于数字的最小整数值。 注意：此函数等于CEILING()函数。 语法 CEIL(number) FLOOR() 函数 实例 返回小于或等于25.75的最大整数值： SELECT FLOOR(25.75); 定义和用法 FLOOR()函数返回小于或等于数字的最大整数值。 注意：还要查看ROUND()，CEIL()，CEILING()，TRUNCATE()和DIV函数。 语法 FLOOR(number) MOD() 函数 实例 返回18/4的剩余部分： SELECT MOD(18, 4); 定义和用法 MOD()函数返回数字除以另一个数字的余数。 语法 MOD(x, y) #要么： x MOD y #要么 x % y 参数值 ROUND() 函数 实例 将数字四舍五入到小数点后2位： SELECT ROUND(135.375, 2); 定义和用法 ROUND()函数将数字四舍五入到指定的小数位数。 注意：另请参见FLOOR()，CEIL()，CEILING()和TRUNCATE()函数。 语法 ROUND(*number*, *decimals*) 参数值 TRUNCATE() 函数 实例 将截断的数字返回到2位小数： SELECT TRUNCATE(135.375, 2); 定义和用法 TRUNCATE()函数将数字截断为指定的小数位数。 注意：另请参见FLOOR()，CEIL()，CEILING()和ROUND()函数。 语法 TRUNCATE(number, decimals) 参数值 Update time： 2020-08-18 "},"MySQL/函数/GROUP_CONCAT函数.html":{"url":"MySQL/函数/GROUP_CONCAT函数.html","title":"GROUP_CONCAT函数","keywords":"","body":"GROUP_CONCAT函数 GROUP_CONCAT(expr)函数会从 expr 中连接所有非 NULL 的字符串。如果没有非 NULL 的字符串，那么它就会返回 NULL。 MySQL 的 GROUP_CONCAT 函数详解 group_concat([DISTINCT] 要连接的字段(可以是多个) [Order BY ASC/DESC 排序字段] [Separator '分隔符']) Separator 是一个字符串值，它被用于插入到结果值中。缺省为一个逗号 (\",\")，可以通过指定 SEPARATOR \"\" 完全地移除这个分隔符。 1 使用示例 select GROUP_CONCAT(c_id) id from score where s_id = '01'; 【2】可以使用 DISTINCT 过滤重复的值，也可以加入 ORDER BY 对值进行排序，还可以使用 SEPARATOR 指定分隔符： select GROUP_CONCAT(c_id separator ' ') id from score where s_id = '01'; 如果将多个字段进行连接，会首先将这几个字段连接，然后再用指定的分隔符连接前面拼接好的字符串 select GROUP_CONCAT(c_id,s_id separator '-') id from score where s_id = '01'; 2 最大值限制 GROUP_CONCAT()是有最大长度限制的，默认值是 1024。 可以通过 group_concat_max_len 参数进行动态设置。参数范围可以是 Global 或 Session。 设置语法如下： SET [GLOBAL |SESSION] group_concat_max_len= val 示例 SET SESSION group_concat_max_len=18446744073709551615; SELECT GROUP_CONCAT(a.REGION_ID) FROM t_region a; Update time： 2020-08-19 "},"MySQL/函数/CONCAT函数.html":{"url":"MySQL/函数/CONCAT函数.html","title":"CONCAT函数","keywords":"","body":"CONCAT函数 CONCAT()函数 CONCAT（）函数用于将多个字符串连接成一个字符串。 使用数据表Info作为示例，其中SELECT id,name FROM info LIMIT 1;的返回结果为 +----+--------+ | id | name | +----+--------+ | 1 | BioCyc | +----+--------+ 1、语法及使用特点： CONCAT(str1,str2,…) 返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。可以有一个或多个参数。 2、使用示例： SELECT CONCAT(id, ‘，’, name) AS con FROM info LIMIT 1;返回结果为 +----------+ | con | +----------+ | 1,BioCyc | +----------+ SELECT CONCAT(‘My’, NULL, ‘QL’); 返回结果为 +--------------------------+ | CONCAT('My', NULL, 'QL') | +--------------------------+ | NULL | +--------------------------+ 3、如何指定参数之间的分隔符 Update time： 2020-08-19 "},"MySQL/函数/CONCAT_WS函数.html":{"url":"MySQL/函数/CONCAT_WS函数.html","title":"CONCAT_WS函数","keywords":"","body":"GROUP_WS函数 CONCAT_WS()函数 使用函数CONCAT_WS()。使用语法为： CONCAT_WS(separator,str1,str2,…) CONCAT_WS()代表 CONCAT With Separator ，是CONCAT()的特殊形式。 第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。如果分隔符为 NULL，则结果为 NULL。函数会忽略任何分隔符参数后的 NULL 值。但是CONCAT_WS()不会忽略任何空字符串。 (然而会忽略所有的 NULL）。 select concat_ws('-',c_id,s_id) from score where s_id='01'; 参考 mysql中函数CONCAT及GROUP_CONCAT的使用 MySQL 的 GROUP_CONCAT 函数详解 Update time： 2020-08-19 "},"MySQL/函数/substring_index函数.html":{"url":"MySQL/函数/substring_index函数.html","title":"substring_index函数","keywords":"","body":"substring_index函数 截取字符串的函数：substring_index。 用法规则： substring_index（“待截取有用部分的字符串”，“截取数据依据的字符”，截取字符的位置N） 详细说明： 首先，设待处理对象字符串为“15,151,152,16”（虽然这里指的不是iP，可以看作是IP来处理吧） 这里截取的依据是逗号：“，” 具体要截取第N个逗号前部分的字符; 意思是：在字符串中以逗号为索引，获取不同索引位的字符。 取第一个逗号前的字符串 ： root@localhost|iris>SELECT SUBSTRING_INDEX('15,151,152,16',',',1); +----------------------------------------+ | SUBSTRING_INDEX('15,151,152,16',',',1) | +----------------------------------------+ | 15 | +----------------------------------------+ 1 row in set (0.00 sec) 截取第二个逗号前面部分 root@localhost|iris>SELECT SUBSTRING_INDEX('15,151,152,16',',',2); +----------------------------------------+ | SUBSTRING_INDEX('15,151,152,16',',',2) | +----------------------------------------+ | 15,151 | +----------------------------------------+ 1 row in set (0.00 sec) N可以为负数，表示倒数第N个索引字符后面的字符串。有负号的时候，可以将整个字符倒过来看，依旧是第N个字符前面的部分。 截取目标字符串中最后一个含 “，” 位子的后的部分： root@localhost|iris>SELECT SUBSTRING_INDEX('15,151,152,16',',',-1) as 'subrting'; +----------+ | subrting | +----------+ | 16 | +----------+ 1 row in set (0.00 sec) 取倒数第2个逗号前那部分字符串里，最后逗号后面的部分 root@localhost|iris>SELECT SUBSTRING_INDEX(SUBSTRING_INDEX('15,151,152,16',',',2),',',-1) as 'subrting'; +----------+ | subrting | +----------+ | 151 | +----------+ 1 row in set (0.00 sec) 参考： mysql函数substring_index的用法 Update time： 2020-08-25 "},"MySQL/函数/convert函数.html":{"url":"MySQL/函数/convert函数.html","title":"convert函数","keywords":"","body":"convert函数 MySQL 的CAST()和CONVERT()函数可用来获取一个类型的值，并产生另一个类型的值。两者具体的语法如下： CAST(value as type); CONVERT(value, type); 就是CAST(xxx AS 类型), CONVERT(xxx,类型)。 可以转换的类型是有限制的。这个类型可以是以下值其中的一个： 二进制，同带binary前缀的效果 : BINARY 字符型，可带参数 : CHAR() 日期 : DATE 时间: TIME 日期时间型 : DATETIME 浮点数 :DECIMAL 整数 : SIGNED 无符号整数 :UNSIGNED 举例 mysql> SELECT CONVERT('23',SIGNED); +----------------------+ | CONVERT('23',SIGNED) | +----------------------+ | 23 | +----------------------+ 1 row in set 在SQL Server中，下面的代码演示了datetime变量中，仅包含单纯的日期和单纯的时间时，日期存储的十六进制存储表示结果。 DECLARE @dt datetime --单纯的日期 SET @dt='1900-1-2' SELECT CAST(@dt as binary(8)) --结果: 0x0000000100000000 --单纯的时间 SET @dt='00:00:01' SELECT CAST(@dt as binary(8)) --结果: 0x000000000000012C Update time： 2020-09-09 "},"MySQL/notebooks/notebooks.html":{"url":"MySQL/notebooks/notebooks.html","title":"notebooks","keywords":"","body":"notebooks Update time： 2020-08-18 "},"MySQL/notebooks/WHERE和HAVING、ON有什么区别？.html":{"url":"MySQL/notebooks/WHERE和HAVING、ON有什么区别？.html","title":"WHERE和HAVING、ON有什么区别？","keywords":"","body":"WHERE和HAVING、ON有什么区别？ SQL 提供了多种对数据进行过滤的方式，包括 WHERE、HAVING以及ON子句等。虽然它们都能够实现类似的功能，但是你知道它们之间的区别吗？ WHERE 和 HAVING、ON 有什么区别？ WHERE 与 HAVING WHERE与HAVING的根本区别在于： WHERE子句在GROUP BY分组和聚合函数之前对数据行进行过滤； HAVING子句对GROUP BY分组和聚合函数之后的数据行进行过滤。 因此，WHERE子句中不能使用聚合函数。 WHERE 与 ON 当查询涉及多个表的关联时，我们既可以使用WHERE子句也可以使用ON子句指定连接条件和过滤条件。这两者之间的主要区别在于： 对于内连接（inner join）查询，WHERE和ON中的过滤条件等效； 对于外连接（outer join）查询，ON中的过滤条件在连接操作之前执行，WHERE中的过滤条件（逻辑上）在连接操作之后执行。 对于内连接查询而言，以下三个语句的结果相同： -- 语句 1 select d.dept_name, e.emp_name, e.sex, e.salary from employee e, department d where e.dept_id = d.dept_id and e.emp_id = 10; dept_name|emp_name|sex|salary | ---------|--------|---|-------| 研发部 |廖化 |男 |6500.00| -- 语句 2 select d.dept_name, e.emp_name, e.sex, e.salary from employee e join department d on (e.dept_id = d.dept_id and e.emp_id = 10); dept_name|emp_name|sex|salary | ---------|--------|---|-------| 研发部 |廖化 |男 |6500.00| -- 语句 3 select d.dept_name, e.emp_name, e.sex, e.salary from employee e join department d on (e.dept_id = d.dept_id) where e.emp_id = 10; dept_name|emp_name|sex|salary | ---------|--------|---|-------| 研发部 |廖化 |男 |6500.00| 语句 1 在WHERE中指定连接条件和过滤条件；语句 2 在ON中指定连接条件和过滤条件；语句 3 在ON中指定连接条件，在WHERE中指定其他过滤条件。 尽管如此，仍然建议将两个表的连接条件放在ON子句中，将其他过滤条件放在WHERE子句中；这样语义更加明确，更容易阅读和理解。对于上面的示例而言，推荐使用语句 3 的写法。 对于外连接而言，连接条件只能用ON子句表示，因为WHERE子句无法表示外连接的语义。 Update time： 2020-08-18 "},"MySQL/notebooks/mysql的分组排序和变量赋值顺序.html":{"url":"MySQL/notebooks/mysql的分组排序和变量赋值顺序.html","title":"mysql的分组排序和变量赋值顺序","keywords":"","body":"mysql的分组排序和变量赋值顺序 有个这样的需求是，根据不同性别进行分组排序他们的年龄，并得到序列号 CREATE TABLE person (id int, first_name varchar(20), age int, gender char(1)); INSERT INTO person VALUES (1, 'Bob', 25, 'M'); INSERT INTO person VALUES (2, 'Jane', 20, 'F'); INSERT INTO person VALUES (3, 'Jack', 30, 'M'); INSERT INTO person VALUES (4, 'Bill', 32, 'M'); INSERT INTO person VALUES (5, 'Nick', 22, 'M'); INSERT INTO person VALUES (6, 'Kathy', 18, 'F'); INSERT INTO person VALUES (7, 'Steve', 36, 'M'); INSERT INTO person VALUES (8, 'Anne', 25, 'F'); 先来得到想要的结果 select first_name, gender, age , rank from (select first_name, gender, age, @rank:=if(@gen=gender,@rank+1,1) rank, @gen:=gender from person,(select @rank:=0,@gen:=null) temp order by gender, age asc) b 简便方法 select first_name, age, gender, dense_rank() over ( partition by gender order by age) rk from person; mysql 变量解释 通过 set赋值变量 通过 select赋值变量 解释上面的分组排序代码 第一步先赋值变量 第二步使用IF条件进行分组 下面，我们不要太关注from person,(select @rank:=0,@gen:=null) temp，就是当作进行变量的初始化就好 select first_name, gender, age, @rank:=if(@gen=gender,@rank+1,1) rank, @gen:=gender from person,(select @rank:=0,@gen:=null) temp order by gender, age asc a.第一步：变量赋值，是先运行from 后面的内容，以及排序，排序的目的是把 F、M放到各自的组中（这一点和我们原来的先select 后order 是不一样的，等下会有说明）此时@rank等于0,@gen等于null b.第二步： 开始进行select中的内容，会先进行 第一行，运行 @rank:=if(@gen=gender,@rank+1,1) rank，此时@gen是等于null的，而gender 是第一行的值，所以IF函数将会返回1，第一行的rank就会返回1，接着运行@gen:=gender ，此时的@gen会被赋值第一行的值 第二行, 还是先运行@rank:=if(@gen=gender,@rank+1,1) rank，此时的@gen是等于gender，根据IF会返回@rank+1 然后赋值到@rank，直到遇到下一个不一样的gender，@rank 才会重新变成1 变量赋值顺序 set @rownum:=0; select first_name, gender, age, @rownum as rownum from person where @rownum 在sql 语句中的执行顺序是 from 、where 、select 、order by 在这我们的疑问是先进行的order by 后进行的 select 如果是先进行的select 的话，rownum会输出0、1，而真实的结果是 rownnum是输出的1、2 所以我们可以暂认为是先进行的order by 后进行的 select，因为没有找到官方的说明。 注意事项 mysql 的变量赋值有= 和 :=，这两种形式，但是在select 后面的赋值，要用:=这种形式，如果不用就会出现这样的问题。 作者：数据蛙datafrog 链接：https://www.jianshu.com/p/d732d1cb1a89 来源：简书 Update time： 2020-08-25 "},"MySQL/notebooks/累加计算.html":{"url":"MySQL/notebooks/累加计算.html","title":"累加计算","keywords":"","body":"累加计算 在mysql中实现如上数据累加效果，可使用 set，定义用户变量。 sql 语句： SET @x = 0; SELECT t1.months, t1.register_num , @x := @x+t1.register_num AS total FROM ( SELECT DATE_FORMAT(createTime, \"%Y%m\") months, count(id) AS register_num FROM t_user GROUP BY months asc ) t1 案例 create table userlog2 ( id int, name varchar(10), EmailAddress varchar(50), lastlogon varchar(50) ); insert into userlog2 values (100, 'test4', 'test4@yahoo.cn', '2007-11-25 16:31:26'), (13, 'test1', 'test1@yahoo.cn', '2007-3-22 16:27:07'), (19, 'test1', 'test1@yahoo.cn', '2007-10-25 14:13:46'), (42, 'test1', 'test1@yahoo.cn', '2007-10-25 14:20:10'), (45, 'test2', 'test2@yahoo.cn', '2007-4-25 14:17:39'), (49, 'test2', 'test2@yahoo.cn', '2007-5-25 14:22:36'); 生成一张临时表，表名自定，四列数据，分别是：Name, Last Logor, Num logontime（要求按时间给出每个人的登录次数，登录时间最早的为1，之后分别为2,3,4等）， Num logonday（要求：按天给出每个人的登录次数，同一天多次登录认为是同一次，最早的一次标记为1，之后的依次类推） DROP TABLE IF EXISTS tmp_table; CREATE TEMPORARY TABLE tmp_table select user2.name as Name, user2.time1 as lastlogon, user2.rank1 as num_logontime, user2.rank2 as num_logonday from (select *, @rank := if(@nam = user1.name, @rank + 1, 1) rank1, @rank1 := if(@nam = user1.name, if(@da = user1.day1, @rank1, @rank1 + 1), 1) rank2, @nam := user1.name, @da := user1.day1 from (select name, EmailAddress, date_format(lastlogon, '%Y-%m-%d %H:%i:%s') as time1, date_format(substring_index(lastlogon, ' ', 1), '%Y-%m-%d') as day1 from userlog2 order by name asc, time1 asc ) as user1, (select @rank := 0 , @rank1 := 0 , @nam := null , @da := null) temp order by user1.name, user1.time1) as user2 ; select * from tmp_table Update time： 2020-08-25 "},"MySQL/notebooks/MYSQL列转行、行转列.html":{"url":"MySQL/notebooks/MYSQL列转行、行转列.html","title":"MYSQL列转行、行转列","keywords":"","body":"MYSQL列转行、行转列 MYSQL列转行 用 union / union all函数 数据导入 create table a1 ( name varchar(20), english int, maths int, music int ); insert into a1 values (\"Jim\", 90, 88, 99); select * from a1; select name, 'english' as subject, english as score from a1 union select name, 'maths' as subject, maths as subject from a1 union select name, 'music' as subject, music as subject from a1; select name, 'english' as subject, english as score from a1 select 可以将表中没有的字段筛选出来，如本题中的 'english' as subject , 注意引号的使用。 MYSQL行转列 用 max函数 create table tb( 姓名 varchar(10), 课程 varchar(3), 分数 int(3) ); insert into tb values ('张三','语文', 74), ('张三','数学', 83), ('张三','物理', 93), ('李四','语文', 74), ('李四','数学', 84), ('李四','物理', 94); 想要显示的结果是 ：姓名 语文 数学 物理 这种形式的（就是行转列） SELECT `姓名`, MAX(CASE `课程` WHEN '语文' THEN `分数` ELSE 0 END) '语文', MAX(CASE `课程` WHEN '数学' THEN `分数` ELSE 0 END) '数学', MAX(CASE `课程` WHEN '物理' THEN `分数` ELSE 0 END) '物理' FROM TB GROUP BY `姓名`; 参考 MySQL case when 与 max() 聚合函数联合使用 Update time： 2020-08-26 "},"MySQL/笔试/笔试题集合.html":{"url":"MySQL/笔试/笔试题集合.html","title":"笔试题集合","keywords":"","body":"笔试题集合 Update time： 2020-09-08 "},"MySQL/笔试/阿里数据分析岗的秋招SQL题20190828.html":{"url":"MySQL/笔试/阿里数据分析岗的秋招SQL题20190828.html","title":"阿里数据分析岗的秋招SQL题(2019.8.28)","keywords":"","body":"阿里数据分析岗的秋招SQL题(2019.8.28) 题目 name: table_t001 表table_t001， user_id（用户名）、dt（购买日期）、amt（购买金额），找出购买天数最多的用户和购买金额最多的用户，按要求输出用户id、购买天数、购买金额，备注是购买天数最多还是购买金额最多。 思路 建立临时表，按user_id 统计购买天数和购买总金额； 对临时表查找购买天数最大和购买总金额最多的记录； 相应添加备注。 SQL 初实现 创建临时表 -- 临时表 v_tablet001 CREATE VIEW v_tablet001 AS SELECT user_id, COUNT(DISTINCT dt) AS dt_count, SUM(amt) AS acc_amt FROM table_t001 GROUP BY user_id; 临时表 v_tablet001 查找购买天数最大和购买总金额最多的记录，分别备注，两条记录用UNION合并。 -- 查询 SELECT user_id, dt_count '购买天数', acc_amt '购买金额', '最大购买天数' AS '备注' FROM v_tablet001 WHERE dt_count = (SELECT MAX(dt_count) FROM v_tablet001) UNION SELECT user_id, dt_count '购买天数', acc_amt '购买金额', '最大购买金额' AS '备注' FROM v_tablet001 WHERE acc_amt = (SELECT MAX(acc_amt) FROM v_tablet001); 题目的严谨性 至此，已经筛选出符合题目条件的记录。 但是，你有没有想过 如果有「同时是最大购买天数和最大购买金额」的情况呢？ 如何根据情况判断，自动匹配备注，而不是手动提前判断并备注呢？ 完善一下题目， 找出购买天数最多的用户和购买金额最多的用户，按要求输出用户id、购买天数、购买金额，备注是「购买天数最多」还是「购买金额最多」还是「同时购买天数和购买金额都最多」。 新添加一条数据，创造第三种情况。新数据如下， 更严谨的SQL实现 同样，建临时表，按user_id 统计购买天数和购买总金额 -- 建临时表 v_tablet001 CREATE VIEW v_tablet001 AS SELECT user_id, COUNT(DISTINCT dt) AS dt_count, SUM(amt) AS acc_amt FROM table_t001 GROUP BY user_id; 考虑用CASE WHEN 分情况添加备注。 -- 查询，CASE WHEN 条件判断 SELECT user_id, dt_count '购买天数', acc_amt '购买金额', note '备注' FROM (SELECT *, CASE WHEN dt_count = (SELECT MAX(dt_count) FROM v_tablet001) AND acc_amt <> (SELECT MAX(acc_amt) FROM v_tablet001) THEN '最大购买天数' WHEN acc_amt = (SELECT MAX(acc_amt) FROM v_tablet001) AND dt_count <> (SELECT MAX(dt_count) FROM v_tablet001) THEN '最大购买金额' WHEN dt_count = (SELECT MAX(dt_count) FROM v_tablet001 ) AND acc_amt = (SELECT MAX(acc_amt) FROM v_tablet001) THEN '同时购买天数和购买金额都最多' END AS note FROM v_tablet001) AS new_table WHERE note IS NOT NULL; SQL优化 第四部分的代码，在查询「购买天数最多」、「购买金额最多」、「同时购买天数和购买金额都最多」还可以优化，毕竟子查询的效率不够高。 思路：用RANK()分别对购买天数和购买金额逆序排序，筛选排名第一的记录。 -- 查询，CASE WHEN 条件判断 SELECT user_id, dt_count '购买天数', acc_amt '购买金额', CASE WHEN rank1 = 1 AND rank2 = 1 THEN '同时购买天数和购买金额都最多' WHEN rank1 = 1 AND rank2 <> 1 THEN '最大购买天数' WHEN rank2 = 1 AND rank1 <> 1 THEN '最大购买金额' END AS note FROM (SELECT user_id, dt_count, acc_amt, RANK() OVER (ORDER BY dt_count DESC) AS rank1, RANK() OVER (ORDER BY acc_amt DESC) AS rank2 FROM v_tablet001) AS t WHERE rank1 = 1 OR rank2 = 1; 如果直接用查询，不产生临时表，效率更高。所以建立临时表，和查询过程可以嵌套在一起，一步完成。 SELECT user_id, dt_count '购买天数', acc_amt '购买金额', CASE WHEN rank1 = 1 AND rank2 = 1 THEN '同时购买天数和购买金额都最多' WHEN rank1 = 1 AND rank2 <> 1 THEN '最大购买天数' WHEN rank2 = 1 AND rank1 <> 1 THEN '最大购买金额' END AS note FROM (SELECT user_id, dt_count, acc_amt, RANK() OVER (ORDER BY dt_count DESC) AS rank1, RANK() OVER (ORder BY acc_amt DESC) AS rank2 FROM ( SELECT user_id, COUNT(DISTINCT dt) AS dt_count, SUM(amt) AS acc_amt FROM table_t001 GROUP BY user_id ) AS t1 -- t1对应原本的临时表 ) AS t2 WHERE rank1 = 1 OR rank2 = 1; 笔记 复习rank()、dense_rank()、row_number() 的区别： MySQL 临时表的建立： temporary 创建临时表 create temporary table tmp_table select * from table_name; view 创建表临时表： create view view_name as select * from table_name; 参考 一道阿里数据分析岗的秋招SQL题 （2019.8.28） Update time： 2020-09-08 "}}